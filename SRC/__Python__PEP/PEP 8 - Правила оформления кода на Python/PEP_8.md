PEP 8 — руководство по стилю написания кода на Python

# Введение

    В этом документе приведены рекомендации по кодированию для кода Python, входящего в стандартную библиотеку основного дистрибутива Python.

# Компоновка кода

## Отступ

    * Используйте 4 пробела на каждый уровень отступа.
    В строках продолжения элементы должны быть выровнены по вертикали с помощью неявного объединения строк в Python внутри круглых, квадратных и фигурных скобок или с помощью отступа [1]. 
    При использовании отступа следует учитывать следующее: в первой строке не должно быть аргументов, а дальнейший отступ должен чётко указывать на то, что это строка продолжения:
    
    + Правильно:
    Добавьте 4 пробела (дополнительный уровень отступа), чтобы отличать аргументы от остальных.
    def long_function_name (
            var_one, var_two, var_three,
            var_four):
        print (var_one)
    Выровнено по разделителю открытия.
    foo = long_function_name (var_one, var_two,
                              var_three, var_four)
    Висячие отступы должны добавить уровень.
    foo = long_function_name (
        var_one, var_two,
        var_three, var_four)

    - Неверно:
    Требуется дополнительный отступ, так как отступ не различим.
    def long_function_name (
        var_one, var_two, var_three,
        var_four):
        print (var_one)
    Аргументы в первой строке запрещены, если не используется вертикальное выравнивание.
    foo = long_function_name (var_one, var_two,
        var_three, var_four)

    * Правило четырёх пробелов необязательно для строк продолжения.
    Необязательный:
    Отступы *могут* быть не равны 4 пробелам.
    foo = long_function_name (
      var_one, var_two,
      var_three, var_four)

    * Если условная часть if-оператора настолько длинная, что её приходится записывать в несколько строк, стоит отметить, что сочетание двухсимвольного ключевого слова (т. е. if), одного пробела и открывающей скобки создаёт естественный отступ в 4 пробела для последующих строк многострочного условного оператора. 
    Это может привести к визуальному конфликту с отступом вложенного в if-оператор блока кода, который также естественным образом имеет отступ в 4 пробела. 
    В этом документе не указано, как (и нужно ли) визуально отличать такие условные строки от вложенного набора внутри if-оператора. 
    Допустимые варианты в этой ситуации включают, помимо прочего, следующее: Без дополнительных отступов.
    if (this_is_one_thing and
        that_is_another_thing):
        pass

    * Добавьте комментарий, который обеспечит некоторое различие в редакторах поддержка подсветки синтаксиса.
    if (this_is_one_thing and
        that_is_another_thing):
        # Поскольку оба условия верны, мы можем выполнить фробнирование.
        pass

    * Добавьте дополнительный отступ в строку условного продолжения.
    if (this_is_one_thing
            and that_is_another_thing):
        pass

    * Закрывающая скобка/фигурная скобка/круглые скобки в многострочных конструкциях могут располагаться под первым символом, не являющимся пробелом, в последней строке списка, например:
    my_list = [
        1, 2, 3,
        4, 5, 6,
        ]
    result = some_function_that_takes_arguments (
        'a', 'b', 'c',
        'd', 'e', 'f',
        )

    * или он может располагаться под первым символом строки, с которой начинается многострочная конструкция, например:
    my_list = [
        1, 2, 3,
        4, 5, 6,
    ]
    result = some_function_that_takes_arguments (
        'a', 'b', 'c',
        'd', 'e', 'f',
    )

## Табуляция или пробелы?

    Пробелы — предпочтительный способ отступа.

## Максимальная Длина линии

    Ограничьте длину всех строк максимум 79 символами.
    Для длинных блоков текста с меньшим количеством структурных ограничений (docstrings или комментарии) 
    длина строки должна быть ограничена 72 символами.
    Ограничение необходимой ширины окна редактора позволяет открывать несколько файлов рядом друг с другом. Это удобно при использовании инструментов для проверки кода, которые отображают две версии в соседних столбцах.
    Перенос по умолчанию в большинстве инструментов нарушает визуальную структуру кода, что затрудняет его понимание. 
    Ограничения выбраны таким образом, чтобы избежать переноса в редакторах с шириной окна 80, даже если инструмент помещает маркерный глиф в последний столбец при переносе строк. Некоторые веб-инструменты могут вообще не поддерживать динамический перенос строк.
    Некоторые команды предпочитают более длинные строки. Для кода, который поддерживается исключительно или в основном командой, способной прийти к согласию по этому вопросу, можно увеличить ограничение на длину строки до 99 символов при условии, что комментарии и строки документации по-прежнему будут переноситься на новую 
    строку при достижении 72 символов.
    Стандартная библиотека Python консервативна и требует, чтобы длина строк не превышала 79 символов (а строк документации/комментариев — 72 символов).
    Предпочтительный способ переноса длинных строк — использование подразумеваемого продолжения строки в Python внутри круглых, квадратных и фигурных скобок. Длинные строки можно разбивать на несколько строк, заключая выражения в круглые скобки. Их следует использовать вместо обратной косой черты для продолжения строки.
    В некоторых случаях использование обратной косой черты по-прежнему уместно. 
    Например, до выхода Python 3.10 в длинных многострочных with-выражениях нельзя было использовать неявное продолжение, поэтому в этом случае можно было использовать обратную косую черту:

    , file_1as)'/путь/к/файлу/который/вы/хотите/прочитать' ( openwith \
    open('/путь/к/файлу/который/вы/хотите/записать', 'w') as file_2:
    file_2.write(file_1.read())

    Другой подобный случай связан с операторами assert.

## Должен ли перенос строки стоять до или после бинарного оператора?

    На протяжении десятилетий рекомендовалось делать перенос после бинарных операторов. Но это может негативно сказаться на читабельности по двум причинам: операторы, как правило, располагаются в разных столбцах на экране, 
    и каждый оператор переносится на предыдущую строку вместе со своим операндом. В этом случае глазу приходится прилагать дополнительные усилия, чтобы понять, какие элементы складываются, а какие вычитаются.
    
    - Неверно:
    операторы находятся далеко от своих операндов
    income = (gross_wages +
              taxable_interest +
              (dividends - qualified_dividends) -
              ira_deduction -
              student_loan_interest)

    Чтобы решить эту проблему с читабельностью, математики и их издатели придерживаются противоположного подхода. 
    Дональд Кнут объясняет традиционное правило в своей серии «Компьютеры и вёрстка»: «Хотя формулы в абзаце всегда разрываются после бинарных операций и соотношений, отображаемые формулы всегда разрываются перед бинарными операциями» [3].
    
    + Правильно:
    легко сопоставить операторы с операндами
    income = (gross_wages
              + taxable_interest
              + (dividends - qualified_dividends)
              - ira_deduction
              - student_loan_interest)

## Пустые строки

    Окружите определения функций и классов верхнего уровня двумя пустыми строками.
    Определения методов внутри класса отделяются одной пустой строкой.
    Дополнительные пустые строки можно использовать (в редких случаях) для разделения групп связанных функций. 
    Пустые строки можно не использовать между несколькими связанными однострочными функциями (например, набором фиктивных реализаций).
    Используйте пустые строки в функциях, но не злоупотребляйте ими, чтобы обозначить логические разделы.
    Python воспринимает символ перевода строки control-L (т. е. ^L) как пробел. Многие инструменты рассматривают эти символы как разделители страниц, поэтому вы можете использовать их для разделения страниц связанных разделов вашего файла. Обратите внимание, что некоторые редакторы и веб-приложения для просмотра кода могут не распознавать control-L как символ перевода строки и отображать вместо него другой символ.

## Кодировка исходного файла

    Код в основной версии Python всегда должен использовать кодировку UTF-8 и не должен содержать объявления кодировки.
    В стандартной библиотеке кодировки, отличные от UTF-8, следует использовать только в тестовых целях. 
    Используйте символы, отличные от ASCII, по возможности редко, желательно только для обозначения географических объектов и имён людей. Если вы используете символы, отличные от ASCII, в качестве данных, избегайте «шумных» символов Юникода, таких как z̯̯͡a̧͎̺l̡͓̫g̹̲o̡̼̘, и знаков порядка байтов.
    Все идентификаторы в стандартной библиотеке Python ДОЛЖНЫ использовать только символы ASCII и ПО ВОЗМОЖНОСТИ ДОЛЖНЫ состоять из английских слов (во многих случаях используются сокращения и технические термины, которые не являются английскими).
    Проектам с открытым исходным кодом, ориентированным на глобальную аудиторию, рекомендуется придерживаться аналогичной политики.

## Импорт

    * Импорты обычно указываются в отдельных строках:
    
    + Правильно: 
    import os
    import sys
    
    - Неверно: 
    import sys, os
    
    Но можно сказать и так:
    
    + Правильно: 
    from subprocess import Popen, PIPE

    * Импорты всегда располагаются в верхней части файла, сразу после комментариев и строк документации модуля и перед глобальными переменными и константами модуля.

    Импорты следует группировать в следующем порядке:
    1. Импорт стандартной библиотеки.
    2. Связанный импорт третьими сторонами.
    3. Импорт для конкретного приложения/библиотеки.

    Между каждой группой импорта следует оставлять пустую строку.

    * Рекомендуется использовать абсолютный импорт, так как он обычно более читабелен и работает лучше (или, по крайней мере, выдаёт более понятные сообщения об ошибках), если система импорта настроена неправильно (например, когда каталог внутри пакета оказывается в sys.path):

    import mypkg.sibling
    from mypkg import sibling
    from mypkg.sibling import example

    Однако явный относительный импорт является приемлемой альтернативой абсолютному импорту, особенно при работе со сложными структурами пакетов, когда использование абсолютного импорта было бы излишне многословным:

    from . import sibling
    from .sibling import example

    В коде стандартной библиотеки следует избегать сложных структур пакетов и всегда использовать абсолютный импорт.

    * При импорте класса из модуля, содержащего классы, обычно допускается такой вариант написания:

    from myclass import MyClass
    from foo.bar.yourclass import YourClass
    
    Если такое написание приводит к конфликту с локальным именем, укажите их явно:

    import myclass
    import foo.bar.yourclass
    
    and use “myclass.MyClass” and “foo.bar.yourclass.YourClass”.

    * Следует избегать импорта с подстановочными знаками (from <module> import *), так как он не даёт понять, какие имена присутствуют в пространстве имён, что сбивает с толку как читателей, так и многие автоматизированные     инструменты. Есть только один допустимый вариант использования импорта с подстановочными 
    знаками — перепубликация внутреннего интерфейса как части общедоступного API (например, перезапись реализации интерфейса на чистом Python определениями из дополнительного модуля-ускорителя, при этом заранее неизвестно, какие именно определения будут перезаписаны).

## Названия модулей уровня Dunder

    «Дундеры» на уровне модуля (то есть имена с двумя ведущими и двумя завершающими символами подчеркивания), такие как __all__, __author__, __version__, и т. д., следует размещать после строки документации модуля, но перед любыми операторами импорта кроме from __future__ импорта из модуля. Python требует, чтобы операторы импорта из модуля располагались в модуле перед любым другим кодом, кроме строк документации:

    """This is the example module.
    This module does stuff.
    """

    from __future__ import barry_as_FLUFL

    __all__ = ['a', 'b', 'c']
    __version__ = '0.1'
    __author__ = 'Cardinal Biggles'

    import os
    import sys

# Строковые кавычки

    В Python строки в одинарных и двойных кавычках ничем не отличаются. В этом PEP нет рекомендаций на этот счёт. Выберите правило и придерживайтесь его. Однако если строка содержит одинарные или двойные кавычки, используйте другие кавычки, чтобы избежать обратных косых черт в строке. Это повышает читаемость. 
    Для строк в тройных кавычках всегда используйте двойные кавычки, чтобы соответствовать соглашению о строках документации в PEP 257.

# Пробелы в выражениях и операторах

## Домашние Мозоли
    Избегайте лишних пробелов в следующих случаях:

    * Сразу после круглых скобок, квадратных скобок или фигурных скобок:
    
    + Правильно:
    spam (ham [1], {eggs: 2})
    
    - Неверно:
    spam ( ham [ 1 ], { eggs: 2 } )

    * Между запятой в конце предложения и закрывающей скобкой:
    
    + Правильно:
    foo = (0,)
    
    - Неверно:
    bar = (0, )

    * Непосредственно перед запятой, точкой с запятой или двоеточием:

    + Правильно:
    if x == 4: print (x, y); x, y = y, x

    - Неверно:
    if x == 4: print (x , y) ; x , y = y , x
    
    Однако в срезе двоеточие действует как бинарный оператор и должно иметь одинаковое количество пробелов с обеих сторон (как оператор с самым низким приоритетом). В расширенном срезе оба двоеточия должны иметь одинаковое количество пробелов. Исключение: если параметр среза опущен, пробел не ставится:

    + Правильно:
    ham [1:9], ham [1:9:3], ham [:9:3], ham [1::3], ham [1:9:]
    ham [lower:upper], ham [lower:upper:], ham [lower::step]
    ham [lower + offset: upper + offset]
    ham [: upper_fn (x): step_fn (x)], ham [:: step_fn (x)]
    ham [lower + offset: upper + offset]

    - Неверно:
    ham[lower + offset:upper + offset]
    ham[1: 9], ham[1 :9], ham[1:9 :3]
    ham[lower : : step]
    ham[ : upper]

    Непосредственно перед открывающей скобкой, которая начинает список аргументов при вызове функции:

    + Правильно:
    spam(1)

    - Неверно:
    spam (1)

    Непосредственно перед открывающей скобкой, с которой начинается индексация или нарезка:

    + Правильно:
    dct['key'] = lst[index]

    - Неверно:
    dct ['key'] = lst [index]

    Несколько пробелов вокруг оператора присваивания (или другого оператора) для выравнивания с другим оператором:

    + Правильно:
    x = 1
    y = 2
    long_variable = 3

    - Неверно:
    x             = 1
    y             = 2
    long_variable = 3

## Другие Рекомендации

    * Избегайте пробелов в конце строки.

    * Всегда окружают эти двоичные операторы с одного места на обе стороны: присвоение (=), дополненная заданием (+=, -= и т. д.), сравнения (==, <, >, !=, <=, >=, in, not in, is, is not), логические значения (and, or, not).

    * Если используются операторы с разными приоритетами, рассмотрите возможность добавления пробелов вокруг операторов с наименьшим приоритетом. Используйте свое собственное суждение; однако никогда не используйте более одного пробела и всегда используйте одинаковое количество пробелов с обеих сторон двоичного оператора:

    + Правильно:
    i = i + 1
    submitted += 1
    x = x*2 - 1
    hypot2 = x*x + y*y
    c = (a+b) * (a-b)

    - Неверно:
    i=i+1
    submitted +=1
    x = x * 2 - 1
    hypot2 = x * x + y * y
    c = (a + b) * (a - b)
   
    * В аннотациях к функциям должны соблюдаться обычные правила использования двоеточий, а вокруг стрелки -> всегда должны быть пробелы, если она присутствует.

    + Правильно:
    def munge(input: AnyStr):
        ...
    def munge() -> PosInt:
        ...

    - Неверно:
    def munge(input:AnyStr):
        ...
    def munge()->PosInt:
        ...

    * Не используйте пробелы вокруг знака = при указании ключевого аргумента или значения по умолчанию для неаннотированного параметра функции:

    + Правильно:
    def complex(real, imag=0.0):
        return magic (r=real, i=imag)

    - Неверно:
    def complex(real, imag = 0.0):
        return magic (r = real, i = imag)

    * Однако при объединении аннотации аргумента со значением по умолчанию используйте пробелы вокруг знака =:

    + Правильно:
    def munge (sep: AnyStr = None):
        ...
    def munge (input: AnyStr, sep: AnyStr = None, limit=1000):
        ...

    - Неверно:
    def munge (input: AnyStr=None):
        ...
    def munge (input: AnyStr, limit = 1000):
        ...

    * Составные предложения (несколько предложений в одной строке) обычно не приветствуются:

    + Правильно:
    if foo == 'blah':
        do_blah_thing ()
    do_one ()
    do_two ()
    do_three ()

    - Скорее нет:
    - Неверно:
    if foo == 'blah': do_blah_thing ()
    do_one ();
    do_two ();
    do_three ()

    * Иногда допустимо размещать if/for/while с небольшим телом в одной строке, но никогда не делайте этого для многоклаузальных операторов. Также не сворачивайте такие длинные строки!
    
    - Скорее нет:
    - Неверно:
    if foo == 'blah': do_blah_thing ()
    for x in lst: total += x
    while t < 10: t = delay ()
    
    - Определенно нет:
    - Неверно:
    if foo == 'blah': do_blah_thing()
    else: do_non_blah_thing()

    try: something()
    finally: cleanup()

    do_one(); do_two(); do_three(long, argument,
                                list, like, this)

    if foo == 'blah': one(); two(); three()

# Когда ставить запятые в конце

    * Запятые в конце обычно необязательны, но они обязательны при создании кортежа из одного элемента. Для большей ясности рекомендуется заключать последний элемент в (технически избыточные) круглые скобки:
    
    + Правильно:
    FILES = ('setup.cfg',)
    
    - Неверно:
    FILES = 'setup.cfg',

    * Когда конечные запятые не нужны, они часто оказываются полезными при использовании системы контроля версий, когда ожидается, что список значений, аргументов или импортируемых элементов будет расширяться с течением времени. Правило заключается в том, чтобы размещать каждое значение (и т. д.) на отдельной строке, всегда добавляя конечную запятую, а закрывающую скобку/скобочку/фигурную скобку — на следующей строке. Однако нет смысла ставить конечную запятую на той же строке, что и закрывающий разделитель (за исключением описанного выше случая с одноэлементными кортежами):
    
    + Правильно:
    FILES = [
        'setup.cfg',
        'tox.ini',
    ]
    initialize (FILES,
                error=True,
                )
    
    - Неверно:
    FILES = ['setup.cfg', 'tox.ini', ]
    initialize (FILES, error=True, )

# Комментарии

    * Комментарии должны быть полными предложениями. Первое слово должно быть написано с заглавной буквы, если только это не идентификатор, который начинается со строчной буквы (никогда не меняйте регистр идентификаторов!).
    
    * Блочные комментарии обычно состоят из одного или нескольких абзацев, состоящих из полных предложений, каждое из которых заканчивается точкой.
    
    * В комментариях, состоящих из нескольких предложений, после точки в конце предложения следует ставить один или два пробела, за исключением последнего предложения.

## Блокировать комментарии

    Блочные комментарии обычно относятся к некоторому (или ко всему) последующему коду и имеют отступ на том же уровне, что и этот код. Каждая строка блочного комментария начинается с # и пробела (если только это не текст с отступом внутри комментария).
    Абзацы внутри блочного комментария разделяются строкой, содержащей один символ #.

## Встроенные комментарии

    Используйте встроенные комментарии с осторожностью.
    Встроенный комментарий — это комментарий, размещённый в той же строке, что и выражение. Встроенные комментарии должны быть отделены от выражения как минимум двумя пробелами. Они должны начинаться с # и одного пробела.
    Встроенные комментарии не нужны и даже отвлекают, если в них говорится об очевидном. Не делайте так:
    
    x = x + 1  # Increment x
    
    Но иногда это бывает полезно:
    
    x = x + 1                 # Compensate for border

## Строки документации

    Правила написания хорошей документации (также известной как «docstrings») увековечены в PEP 257.
    Напишите строки документации для всех общедоступных модулей, функций, классов и методов. 
    Строки документации не нужны для закрытых методов, но у вас должен быть комментарий, описывающий, что делает метод. 
    Этот комментарий должен располагаться после строки def
    PEP 257 описывает правила оформления документации. Обратите внимание, что самое главное — это
    то, что """ в конце многострочной документации должен находиться на отдельной строке:
    
    """Return a foobang
    Optional plotz says to frobnicate the bizbaz first.
    """

    * Для однострочных документации строк, пожалуйста, оставляйте закрывающие """ в той же строке:
    """Return an ex-parrot."""

# Соглашения об именовании

    Правила именования в библиотеке Python немного запутаны, поэтому мы никогда не добьёмся полной согласованности. Тем не менее, вот рекомендуемые на данный момент стандарты именования. Новые модули и пакеты (включая сторонние фреймворки) должны соответствовать этим стандартам, но если в существующей библиотеке используется другой стиль, предпочтение отдаётся внутренней согласованности.

## Главенствующий принцип

    Имена, которые видны пользователю как общедоступные части API, должны соответствовать соглашениям, отражающим скорее использование, чем реализацию.

## Описательный: стили именования
   
    Обычно выделяют следующие стили именования:
    
    * b (одна строчная буква)

    * B (одна заглавная буква)

    * lowercase

    * lower_case_with_underscores

    * UPPERCASE

    * UPPER_CASE_WITH_UNDERSCORES

    * CapitalizedWords (или CapWords, или CamelCase — так названо из-за неровного вида букв [4]). Этот стиль также иногда называют StudlyCaps.
    
    Примечание. При использовании аббревиатур в CapWords все буквы аббревиатуры пишутся с заглавной буквы. Таким образом, HTTPServerError лучше, чем HttpServerError.
    
    mixedCase (отличается от CapitalizedWords начальным строчным символом!)
    Capitalized_Words_With_Underscores (уродливый!)
    
    Также существует стиль использования короткого уникального префикса для группировки связанных имён. В Python он используется нечасто, но упомянут для полноты картины. Например, функция os.stat() возвращает кортеж, элементы которого традиционно имеют такие имена, как st_mode, st_size, st_mtime и так далее. (Это сделано для того, чтобы подчеркнуть соответствие полям структуры системных вызовов POSIX, что помогает программистам, знакомым с этой структурой.)

    Кроме того, распознаются следующие специальные формы с начальным или конечным символом подчеркивания (как правило, их можно сочетать с любым регистром):
    
    * _single_leading_underscore: слабый индикатор «внутреннего использования». Например, from M import * не импортирует объекты, имена которых начинаются с символа подчеркивания.
    
    * single_trailing_underscore_: используется по соглашению, чтобы избежать конфликтов с ключевыми словами Python, например :

    tkinter.Toplevel(master, class_='ClassName')

    * __double_leading_underscore: при именовании атрибута класса происходит искажение имени (внутри класса FooBar __boo становится _FooBar__boo; см. ниже).
    
    * __double_leading_and_trailing_underscore__: «волшебные» объекты или атрибуты, которые находятся в пространствах имён, управляемых пользователем. Например, __init__, __import__ или __file__. Никогда не придумывайте такие имена, используйте только те, которые указаны в документации.

### Имена, которых следует избегать
    
    Никогда не используйте символы «l» (строчная буква el), «O» (заглавная буква oh) или «I» (заглавная буква eye) в качестве имён переменных, состоящих из одного символа.

### Совместимость с ASCII
    
    Идентификаторы, используемые в стандартной библиотеке, должны быть совместимы с ASCII, как описано в разделе о политикеPEP 3131.

### Названия пакетов и модулей
    
    Модули должны иметь короткие имена, состоящие только из строчных букв. В имени модуля можно использовать символы подчеркивания, если это улучшает читаемость. Пакеты Python также должны иметь короткие имена, 
    состоящие только из строчных букв, хотя использование символов подчеркивания не рекомендуется.

### Имена классов
    
    Обычно в названиях классов используется соглашение CapWords.
    Соглашение об именовании функций может использоваться в тех случаях, когда интерфейс задокументирован и используется в основном как вызываемый объект.
    Обратите внимание, что для встроенных имён существует отдельное соглашение: большинство встроенных имён состоят из одного слова (или двух слов, соединённых вместе), а соглашение CapWords используется только для имён исключений и встроенных констант.

### Введите Имена переменных [Type Variable Names]
    
    Имена переменных типа, введенные в PEP 484, обычно должны состоять из заглавных букв, при этом предпочтение отдается коротким именам: T, AnyStr, Num. Рекомендуется добавлять суффиксы _co или _contra к переменным, используемым для объявления ковариантного или контравариантного поведения соответственно:
    from typing import TypeVar

    VT_co = TypeVar ('VT_co', covariant=True)
    KT_contra = TypeVar ('KT_contra', contravariant=True)

### Имена исключений
    
    Поскольку исключения должны быть классами, здесь применяется соглашение об именовании классов. 
    Однако в названиях исключений следует использовать суффикс «Error» (если исключение действительно является ошибкой).

### Имена глобальных переменных
    
    (Будем надеяться, что эти переменные предназначены для использования только внутри одного модуля.) Правила примерно такие же, как и для функций.
    Модули, предназначенные для использования через from M import *, должны использовать механизм __all__ для предотвращения экспорта глобальных переменных или следовать старому соглашению и добавлять к таким глобальным переменным префикс в виде подчеркивания (что может указывать на то, что эти глобальные переменные «не являются общедоступными в модуле»).

### Имена функций и переменных
    
    Имена функций должны быть написаны строчными буквами, а слова при необходимости разделяться символом подчеркивания для удобства чтения.
    Имена переменных соответствуют тому же правилу, что и имена функций.
    mixedCase допускается только в тех случаях, когда это уже устоявшийся стиль (например, в файле threading.py), чтобы сохранить обратную совместимость.

### Аргументы функции и метода
    
    Всегда используйте self в качестве первого аргумента для методов экземпляра.
    Всегда используйте cls в качестве первого аргумента для методов класса.
    Если имя аргумента функции совпадает с зарезервированным ключевым словом, то, как правило, 
    лучше добавить в конце символ подчеркивания, а не использовать сокращение или неправильное написание. Таким образом, class_ лучше, чем clss. (Возможно, лучше избегать таких совпадений, используя синонимы.)

### Имена методов и переменные экземпляра
    
    Используйте правила именования функций: пишите все слова с маленькой буквы и разделяйте их символами подчеркивания, чтобы улучшить читаемость.
    Используйте одно ведущее подчеркивание только для непубличных методов и переменных экземпляра.
    Чтобы избежать конфликтов имён с подклассами, используйте два ведущих символа подчёркивания, чтобы активировать правила искажения имён в Python.
    Python объединяет эти имена с именем класса: если у класса Foo есть атрибут с именем __a, к нему нельзя получить доступ с помощью Foo.__a. (настойчивый пользователь всё же может получить доступ, вызвав Foo._Foo__a.) Как правило, двойное нижнее подчёркивание следует использовать только для того, чтобы избежать конфликтов имён с атрибутами в классах, предназначенных для создания подклассов.
    Примечание: использование __names вызывает некоторые разногласия (см. ниже).

### Константы
    
    Константы обычно определяются на уровне модуля и записываются заглавными буквами с использованием символов подчеркивания для разделения слов. Примеры: MAX_OVERFLOW и TOTAL.

### Проектирование для наследования
    
    Всегда решайте, должны ли методы класса и переменные экземпляра (в совокупности: «атрибуты») быть общедоступными или закрытыми. Если сомневаетесь, выбирайте закрытые; позже их будет проще сделать общедоступными, чем сделать общедоступный атрибут закрытым.
    Открытые атрибуты — это те атрибуты, которые, как вы ожидаете, будут использовать сторонние клиенты вашего класса, при этом вы обязуетесь избегать изменений, приводящих к обратной несовместимости. Закрытые атрибуты не предназначены для использования третьими лицами. Вы не даёте никаких гарантий, 
    что закрытые атрибуты не изменятся или даже не будут удалены.
    Мы не используем здесь термин «приватный», поскольку в Python ни один атрибут не является приватным (без, как правило, ненужной дополнительной работы).
    Другая категория атрибутов — это атрибуты, которые являются частью «API подкласса» (в других языках их часто называют «защищёнными»). Некоторые классы предназначены для наследования, чтобы расширить или изменить аспекты поведения класса. При разработке такого класса необходимо чётко определить, какие атрибуты являются открытыми, какие — частью API подкласса, а какие действительно должны использоваться только базовым классом.
    Учитывая это, мы предлагаем следующие рекомендации по Python:
    
    * В общедоступных атрибутах не должно быть ведущих символов подчеркивания.
    
    * Если имя вашего открытого атрибута совпадает с зарезервированным ключевым словом, добавьте в конец имени атрибута один символ подчеркивания. Это предпочтительнее, чем сокращение или неправильное написание. (Однако, несмотря на это правило, предпочтительным написанием для любой переменной или аргумента, которые, как известно, являются классом, особенно для первого аргумента метода класса, является «cls».)
    Примечание 1. Рекомендации по именованию аргументов для методов класса см. выше.
    
    * Для простых общедоступных атрибутов данных лучше всего использовать только имя атрибута без сложных методов доступа/изменения. Помните, что Python предоставляет простой способ расширения в будущем, если вы обнаружите, что простой атрибут данных должен обладать функциональным поведением. В этом случае используйте свойства, чтобы скрыть функциональную реализацию за простым синтаксисом доступа к атрибутам данных.
    Примечание 1. Старайтесь, чтобы функциональное поведение не имело побочных эффектов, 
    хотя такие побочные эффекты, как кэширование, обычно допустимы.
    Примечание 2. Не используйте свойства для ресурсоёмких операций. Атрибутная нотация создаёт у вызывающей стороны впечатление, что доступ к свойству (относительно) дешёвый.
    
    * Если ваш класс предназначен для создания подклассов и у вас есть атрибуты, которые вы не хотите, чтобы использовались в подклассах, подумайте о том, чтобы назвать их с двумя ведущими символами подчеркивания и без завершающего символа подчеркивания. Это задействует алгоритм искажения имен в Python, при котором имя класса преобразуется в имя атрибута. Это помогает избежать конфликтов имен атрибутов, если в подклассах случайно окажутся атрибуты с одинаковыми именами.
    Примечание 1. Обратите внимание, что в искажённом имени используется только простое имя класса, поэтому, если подкласс использует то же имя класса и имя атрибута, могут возникнуть конфликты имён.
    Примечание 2. Из-за искажения имён некоторые функции, например отладка и __getattr__(), становятся менее удобными. Однако алгоритм искажения имён хорошо задокументирован, и его легко выполнить вручную.
    Примечание 3. Не всем нравится искажение имён. Постарайтесь найти баланс между необходимостью избегать случайных конфликтов имён и возможностью их использования опытными пользователями.

## Публичные и Внутренние интерфейсы
    
    Любые гарантии обратной совместимости распространяются только на общедоступные интерфейсы. 
    Соответственно, важно, чтобы пользователи могли чётко различать общедоступные и внутренние интерфейсы.
    Документированные интерфейсы считаются открытыми, если в документации прямо не указано, что они являются временными или внутренними интерфейсами, на которые не распространяются обычные гарантии обратной совместимости. Все недокументированные интерфейсы следует считать внутренними.
    Чтобы лучше поддерживать интроспекцию, модули должны явно указывать имена в своём общедоступном API с помощью атрибута __all__ . Если __all__ указывает на пустой список, это означает, что у модуля нет общедоступного API.
    Даже если __all__ заданы правильно, внутренние интерфейсы (пакеты, модули, классы, функции, атрибуты и другие имена) всё равно должны начинаться с одного символа подчёркивания.
    Интерфейс также считается внутренним, если любое содержащее его пространство имён (пакет, модуль или класс) считается внутренним.
    Импортированные имена всегда следует рассматривать как деталь реализации. Другие модули не должны полагаться на косвенный доступ к таким импортированным именам, если только они не являются явно задокументированной частью API содержащего модуля, например os.path или __init__-модуля пакета, 
    который предоставляет функциональные возможности из подмодулей.

# Рекомендации по программированию

    * Код должен быть написан таким образом, чтобы не ставить в невыгодное положение другие
    реализации Python (PyPy, Jython, IronPython, Cython, Psyco и т. д.).
    Например, не полагайтесь на эффективную реализацию конкатенации строк на месте в CPython для операторов 
    в форме a += b или a = a + b. Эта оптимизация ненадёжна даже в CPython (она работает только для некоторых типов) и вообще отсутствует в реализациях, не использующих подсчёт ссылок. В частях библиотеки, чувствительных к производительности, вместо этого следует использовать форму ''.join(). Это обеспечит конкатенацию за линейное время в различных реализациях.
    
    * Сравнение с одиночными значениями, такими как None, всегда следует проводить с помощью is или is not, а не операторов равенства.
    Кроме того, будьте осторожны, когда пишете if x, если на самом деле имеете в виду if x is not None — например, при проверке, было ли переменной или аргументу, которые по умолчанию имеют значение None, присвоено какое-то другое значение. Другое значение может иметь тип (например, контейнер), который может быть ложным в логическом контексте!
    
    * Используйте оператор is not вместо not ... is. Хотя оба выражения функционально идентичны, первое более читабельно и предпочтительнее:
    
    + Правильно:
    if foo is not None:
    
    - Неверно:
    if not foo is None:

    * При реализации операций упорядочивания с расширенными сравнениями лучше всего реализовать все шесть операций (__eq__, __ne__, __lt__, __le__, __gt__, __ge__), а не полагаться на другой код, который выполняет только одно конкретное сравнение.
    Чтобы минимизировать трудозатраты, декоратор functools.total_ordering() предоставляет инструмент для создания недостающих методов сравнения.
    PEP 207 указывает на то, что в Python применяются правила рефлексивности. Таким образом, интерпретатор может поменять местами y > x и x < y, y >= x и x <= y, а также поменять местами аргументы x == y и x != y. Операции sort() и min() гарантированно используют оператор <, а функция max() использует оператор >. Однако лучше реализовать все шесть операций, чтобы избежать путаницы в других контекстах.
    
    * Всегда используйте оператор def вместо оператора присваивания, который напрямую связывает лямбда-выражение с идентификатором:
    
    + Правильно:
    def f (x):
        return 2 * x
    
    - Неверно:
    f = lambda x: 2 * x

    Первая форма означает, что имя результирующего функционального объекта — именно «f», а не общее «<лямбда>». Это более удобно для трассировки и строковых представлений в целом. Использование оператора присваивания лишает лямбда-выражение единственного преимущества перед явным оператором def (то есть возможности быть вложенным в более крупное выражение)

    * Получайте исключения из Exception, а не из BaseException. Прямое наследование от BaseException предназначено для исключений, перехват которых почти всегда является ошибкой.
    Разрабатывайте иерархию исключений, основываясь на различиях, которые могут понадобиться коду перехватывающему исключения, а не на местах, где эти исключения возникают. Старайтесь программно отвечать на вопрос «Что пошло не так?», а не просто сообщать, что «возникла проблема» (см. PEP 3151 в качестве примера того, как этот урок был усвоен для встроенной иерархии исключений)
    Здесь применяются соглашения об именовании классов, хотя к классам исключений следует добавлять суффикс «Error», если исключение является ошибкой. Исключения, не связанные с ошибками, которые используются для нелокального управления потоком или других форм передачи сигналов, не требуют специального суффикса.
    
    * Используйте цепочку исключений надлежащим образом. raise X from Y следует использовать для явной замены без потери исходной трассировки.
     При намеренной замене внутреннего исключения (с помощью raise X from None) убедитесь, что соответствующие данныепередаются в новое исключение (например, сохраняется имя атрибута при преобразовании KeyError в AttributeError или текст исходного исключения встраивается в сообщение нового исключения).
    
    * При перехвате исключений по возможности указывайте конкретные исключения вместо использования пустого блока except::
    try:
        import platform_specific_module
    except ImportError:
        platform_specific_module = None

    Пустое except:-предложение перехватит исключения SystemExit и KeyboardInterrupt, что затруднит прерывание программы с помощью сочетания клавиш Control-C и может скрыть другие проблемы. Если вы хотите перехватить все исключения, сигнализирующие об ошибках в программе, используйте except Exception: (пустое except эквивалентно except BaseException:).
    Хорошее практическое правило: используйте конструкцию «кроме» только в двух случаях:
    Если обработчик исключений будет выводить трассировку на экран или в журнал, пользователь хотя бы будет знать, что произошла ошибка.
    Если коду нужно выполнить какую-то работу по очистке, но при этом позволить исключению распространиться вверх с помощью raise. try...finally, то это может быть лучшим решением.
    
    * При перехвате ошибок операционной системы лучше использовать явную иерархию исключений, появившуюся в Python 3.3, а не интроспекцию значений errno
    
    * Кроме того, во всех операторах try/except ограничьте try минимальным необходимым количеством кода. Это также позволяет избежать маскировки ошибок.
    
    + Правильно:
    try:
        value = collection [key]
    except KeyError:
        return key_not_found (key)
    else:
        return handle_value (value)
    
    - Неверно:
    try:
        # Too broad!
        return handle_value (collection [key])
    except KeyError:
        # Will also catch KeyError raised by handle_value()
        return key_not_found (key)

    * Если ресурс локален для определённого участка кода, используйте оператор with, чтобы обеспечить его быструю и надёжную очистку после использования. Также можно использовать оператор try/finally.
    
    * Контекстные менеджеры должны вызываться с помощью отдельных функций или методов всякий раз, когда они выполняют какие-либо действия, кроме получения и освобождения ресурсов.
    
    + Правильно:
    with conn.begin_transaction ():
        do_stuff_in_transaction (conn)
    
    - Неверно:
    with conn:
        do_stuff_in_transaction (conn)
    
    В последнем примере нет никакой информации о том, что методы __enter__ и __exit__ делают что-то помимо закрытия соединения после транзакции. В этом случае важно быть конкретным.
    
    * Будьте последовательны в операторах return. Либо все операторы return в функции должны возвращать выражение, либо ни один из них не должен этого делать. Если какой-либо оператор return возвращает выражение, то в операторах return, которые не возвращают значение, это должно быть явно указано как return None, а в конце функции (если это достижимо) должен присутствовать явный оператор return:
    
    + Правильно:
    def foo (x):
        if x >= 0:
            return math.sqrt (x)
        else:
            return None
    def bar (x):
        if x < 0:
            return None
        return math.sqrt (x)
    
    - Неверно:
    def foo (x):
        if x >= 0:
            return math.sqrt (x)
    def bar (x):
        if x < 0:
            return
        return math.sqrt (x)

    * Используйте ''.startswith() и ''.endswith() вместо срезов строк для проверки наличия префиксов или суффиксов. Функции startswith() и endswith() более удобны и менее подвержены ошибкам:
    
    + Правильно:
    if foo.startswith ('bar'):
    
    - Неверно:
    if foo [:3] == 'bar':

    * При сравнении типов объектов всегда следует использовать функцию isinstance(), а не сравнивать типы напрямую:

    + Правильно:
    if isinstance (obj, int):

    - Неверно:
    if type (obj) is type (1):

    * Для последовательностей (строк, списков, кортежей) используйте тот факт, что пустые
    последовательности являются ложными:

    + Correct:
    if not seq:
        if seq:

    - Wrong:
    if len (seq):
        if not len (seq):

    * Не пишите строковые литералы, в которых используются значительные пробелы в конце. Такие
    пробелы визуально неотличимы, и некоторые редакторы (или, в последнее время, reindent.py) обрезают их.
    
    * Не сравнивайте логические значения с True или False с помощью ==:

    + Correct:
    if greeting:

    - Wrong:
    if greeting == True:

    - Worse:
    - Wrong:
    if greeting is True:

     Не рекомендуется использовать операторы управления потоком return/break/continue в блоке
    finally конструкции try...finally, где оператор управления потоком выходит за пределы блока finally. Это связано с тем, что такие операторы неявно отменяют любое активное исключение, распространяющееся через блок finally:
    - Wrong:
    def foo ():
        try:
            1 / 0
        finally:
            return 42

## Аннотации к функциям

    С принятием PEP 484 правила оформления аннотаций к функциям изменились.
    
    * В аннотациях к функциям следует использовать синтаксис PEP 484 (в предыдущем разделе приведены
    некоторые рекомендации по форматированию аннотаций).
    
    * Эксперименты со стилями аннотаций, которые ранее рекомендовались в этом PEP, больше не
    приветствуются.
    
    * Однако за пределами стандартной библиотеки теперь поощряются эксперименты в рамках правил PEP
    484. Например, можно разметить большую стороннюю библиотеку или приложение аннотациями типов в стиле PEP 484, проверить, насколько легко было добавить эти аннотации, и оценить, повышает ли их наличие понятность кода.
    
    * Стандартная библиотека Python должна консервативно подходить к использованию таких аннотаций,
    но их можно применять в новом коде и при масштабном рефакторинге.
    
    * Для кода, в котором предполагается иное использование аннотаций функций, рекомендуется добавить
    комментарий следующего вида:
    тип: игнорировать
    в верхней части файла; это указывает средствам проверки типов игнорировать все аннотации. (Более подробные способы отключения сообщений от средств проверки типов можно найти в PEP 484.)
    
    * Как и линтеры, средства проверки типов являются необязательными отдельными инструментами.
    Интерпретаторы Python по умолчанию не должны выдавать никаких сообщений о проверке типов и не должны изменять своё поведение в зависимости от аннотаций.
    
    * Пользователи, которые не хотят использовать средства проверки типов, могут свободно
    игнорировать их. Однако ожидается, что пользователи сторонних библиотек захотят запускать 
    средства проверки типов для этих библиотек. Для этого PEP 484 рекомендует использовать файлы-заглушки: файлы .pyi, которые считываются средством проверки типов вместо соответствующих файлов .py. Файлы-заглушки могут распространяться вместе с библиотекой или отдельно (с разрешения автора библиотеки) через репозиторий typeshed [5].

## Аннотации к переменным

    PEP 526 представил аннотации переменных. Рекомендации по их использованию аналогичны рекомендациям по использованию аннотаций функций, описанным выше:
    
    * После двоеточия в аннотациях к переменным уровня модуля, переменным класса и экземпляра, а
    также локальным переменным должен стоять один пробел.
    
    * Перед двоеточием не должно быть пробела.
    
    * Если в уравнении есть правая часть, то по обе стороны от знака равенства должно быть ровно по
    одному пробелу:
    + Correct:
    code: int
    class Point:
        coords: Tuple [int, int]
        label: str = '<unknown>'
    
    - Wrong:
    code: int  # No space after colon
    code: int  # Space before colon

    class Test:
        result: int = 0  # No spaces around equality sign

# Ссылки
[2]
    Руководство по стилю GNU Mailman от Барри http://barry.warsaw.us/software/STYLEGUIDE.txt
[3]
    The TeXBook Дональда Кнута, страницы 195 и 196.
[4]
    http://www.wikipedia.com/wiki/Camel_case
[5]
    Репозиторий Typeshed https://github.com/python/typeshed

# Авторские права

Этот документ был опубликован в открытом доступе.
Источник: https://github.com/python/peps/blob/main/peps/pep-0008.rst

Последнее изменение: 2025-04-04 00:19:04 GMT