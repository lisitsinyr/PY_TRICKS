#------------------------------------------
# _01_ ():
#------------------------------------------
def _01_ ():
    """_01_"""
#beginfunction
    print (f'#-----------------------------')
    print (f'# {_01_.__name__}')
    print (f'#-----------------------------')

Link: https://t.me/c/1849804501/1197

Дата: 2025-07-01 16:37:13+00:00

Title: Программистика

🟢** Walrus-оператор** `:=` **в Python — как работает и когда
применять**

С Python 3.8 в языке появился новый синтаксис: `:=`. Он
позволяет **присваивать переменные внутри выражений** — без
лишнего кода. Но новички часто не понимают, когда его
использовать и зачем.

📌** Что делает** `:=`?

➡️ Выполняет присваивание **внутри выражения**
➡️ Возвращает это же значение

🗣 Другими словами: можно одновременно *присвоить* и
*использовать* переменную.

👍**Пример 1: Цикл** `while`** без повторного** `input()`

🔴** Старый способ:**
```data = input("Введите что-то: ")
while data != "exit":
    print(f"Вы ввели: {data}")
    data = input("Введите что-то: ")```

🟢 С `:=`:
```while (data := input("Введите что-то: ")) != "exit":
    print(f"Вы ввели: {data}")```

✅ Стало компактнее, логика — та же.
Особенно удобно, если внутри `while` ты используешь
переменную, полученную снаружи.

👍** Пример 2: Условие с присваиванием**

Допустим, ты парсишь строки и хочешь проверить, есть ли
число в строке. Без `:=`:
```match = re.search(r"\d+", text)
if match:
    number = match.group()
    print("Нашли число:", number)```

С `:=`:
```if (match := re.search(r"\d+", text)):
    print("Нашли число:", match.group())```
📌 Меньше кода — не дублируется `re.search(...)`.

**👍**** Пример 3: List comprehension с промежуточным
значением**

🔴** Без** `:=`** приходится писать громоздко:**
```squares = []
for x in range(10):
    sq = x * x
    if sq > 20:
        squares.append(sq)```

🟢 С `:=`:
```squares = [sq for x in range(10) if (sq := x * x) >
20]```
➡️ Здесь `sq := x * x` сохраняет значение, а затем
используется сразу же в условии.

👍** Пример 4: Чтение файла построчно**

Допустим, ты читаешь большой файл и хочешь работать с
построчно обработанными значениями. Раньше:
```line = f.readline()
while line:
    process(line)
    line = f.readline()```

**Теперь:**
```while (line := f.readline()):
    process(line)```

 🔍 **Краткий итог**

💡 **Walrus-оператор полезен, когда:**
✔️ Тебе нужно **одновременно присвоить и использовать
значение**
✔️ Ты хочешь **избежать повторной операции** (input, вызов
функции и т.п.)
✔️ Ты пишешь **компактный генератор или условие**

⚠️ **Не злоупотребляй:**

✖️ Если `:=` ухудшает читаемость — лучше не использовать
✖️ Не путай с обычным `=` — `:=` можно использовать **только
внутри выражения**, `=` — в теле инструкции

💡 **Запомни:
**
✔️ `:=` = присвоение + возврат значения
✔️ Работает в Python 3.8+
✔️ Упрощает код, если использовать с умом

❓ **А ты уже использовал walrus-оператор? Где он реально
помог упростить код?**


#endfunction

#------------------------------------------
#
#------------------------------------------
#beginmodule
if __name__ == "__main__":
    _01_ ()
#endif

#endmodule
