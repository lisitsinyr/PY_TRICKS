# -*- coding: UTF-8 -*-
"""for_.py"""
#------------------------------------------
# for_02_ ():
#------------------------------------------
def for_02_ ():
    """for_02_"""
#beginfunction
    print ('#-----------------------------')
    print ('#', for_02_.__name__)
    print ('#-----------------------------')

    # Link: https://t.me/python_ready/831
    #
    # Дата: 2025-05-29 10:13:34+00:00
    #
    # Title: Python Ready | Программирование
    #
    # **А вы знаете как в питоне работает цикл for под капотом?**
    #
    # Для начала нужно понять, что такое итерируемый объект и
    # итератор. Итерируемый объект — любой объект, элементы
    # которого можно обойти в цикле, для этого у него должна быть
    # реализация метода `__iter__()`:
    # ```nums = [24, 86, 17, 94]
    # print(nums.__iter__()) # <list_iterator object at 0x0...>```
    #
    # Но цикл for работает не с самим объектом, а с его
    # итератором, тк именно итератор имеет реализацию метода
    # `__next__()`, в котором описана логика перебора. Создадим
    # итератор:
    # ```nums_iterator = iter(nums)
    # print(next(nums_iterator)) # 24
    # print(next(nums_iterator)) # 86```
    #
    # Поэтому, когда вы передаете объект в цикл for, под капотом
    # вызывается функция `iter()`, затем работает `next()` до
    # исключения `StopIteration`:
    # ```while True:
    #     try:
    #        print(next(nums_iterator))
    #     except StopIteration:
    #         break```
    #
    # Как это поможет на практике? Представьте, что вам нужно
    # обработать большой файл. Вместо того, чтобы загружать весь
    # файл в память сразу, вы можете использовать итератор, чтобы
    # читать файл построчно.

#endfunction

#------------------------------------------
#
#------------------------------------------
#beginmodule
if __name__ == "__main__":
    for_02_ ()
#endif

#endmodule
