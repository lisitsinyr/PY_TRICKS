#------------------------------------------
# _01_ ():
#------------------------------------------
def _01_ ():
    """_01_"""
#beginfunction
    print (f'#-----------------------------')
    print (f'# {_01_.__name__}')
    print (f'#-----------------------------')

    # Link: https://t.me/zen_of_python/4289
    #
    # Дата: 2025-06-17 08:03:01+00:00
    #
    # Title: Zen of Python
    #
    # **Немного безумные способы определения функций**
    #
    # Мы привыкли определять функции с помощью ключевого слова
    # `def`. Однако Python как язык куда глубже и гибче, чем может
    # показаться на первый взгляд. Существует несколько способов
    # создать функцию — от практичных до откровенно абсурдных.
    #
    # Lambda-функции — минимализм в действии
    #
    # `lambda` позволяет создавать анонимные функции в одну
    # строку. Это удобно, когда функция короткая и используется
    # "на лету", например, в `map()` или `filter()`. Lambda-
    # функции не могут содержать сложную логику или много
    # выражений — только одно выражение, без `return` и вложенных
    # блоков:
    #
    # ```
    # multiply_by_three = lambda x: x * 3
    # print(multiply_by_three(5))
    # ```
    #
    # Это удобно, но не стоит использовать lambda для сложной
    # логики — теряется читаемость.
    #
    #
    # `functools.partial`
    #
    # С помощью `functools.partial` можно создавать функции с уже
    # предзаданными аргументами:
    #
    # ```
    # from functools import partial
    #
    # def power(base, exponent):
    #     return base ** exponent
    #
    # square = partial(power, exponent=2)
    # print(square(5))  # 25
    # ```
    #
    # Это очень удобно, если вы часто вызываете функцию с одними и
    # теми же аргументами и не хотите писать обёртки.
    #
    # Декораторы
    #
    # Декораторы позволяют оборачивать функции и изменять их
    # поведение — например, добавлять логирование, кэширование или
    # даже модифицировать аргументы:
    #
    # ```
    # def print_result(fmt):
    #     def decorator(func):
    #         def wrapper(*args, **kwargs):
    #             result = func(*args, **kwargs)
    #             print(fmt.format(result))
    #             return result
    #         return wrapper
    #     return decorator
    #
    # @print_result("Результат: {}")
    # def double(x):
    #     return x * 2
    #
    # double(4)
    # ```
    #
    # Мощный инструмент, но при чрезмерном использовании может
    # запутать читаемость кода.
    #
    # Классы с методом `__call__`
    #
    # В Python можно сделать объект вызываемым, определив метод
    # `__call__`. Таким образом, вы можете создавать функции как
    # объекты с состоянием:
    #
    # ```
    # class Greeter:
    #     def __call__(self, name):
    #         print(f"Hello, {name}!")
    #
    # greet = Greeter()
    # greet("Bob")
    # ```
    #
    # Бонус — можно хранить состояние внутри объекта, например,
    # счётчик вызовов.
    #
    # `exec()`
    #
    # `exec()` выполняет строку как код Python. Да, вы можете
    # определять функции с его помощью.
    #
    # ```
    # code = '''
    # def add(x):
    #     return x + 10
    # '''
    # exec(code)
    # print(add(5))  # 15
    # ```
    #
    # Этот способ может быть полезен для метапрограммирования,
    # например, если нужно дать пользователю возможность писать
    # код в аналитической панели. Но использовать его нужно с
    # большой осторожностью из-за проблем безопасности и отладки.
    #
    # `eval()`
    #
    # `eval()` — ещё один способ выполнить строку кода, но только
    # если это выражение, а не целый блок.
    #
    # ```
    # add = eval("lambda x: x + 10")
    # print(add(3))  # 13
    # ```
    #
    # Те же плюсы и минусы, что и у `exec()`.
    #
    # `types.new_class`
    #
    # С помощью `types.new_class()` можно создавать callable-
    # объекты (через `__call__`) на лету.
    #
    # ```
    # import types
    #
    # def class_body(ns):
    #     ns['__call__'] = lambda self, x: x * 2
    #
    # DynamicFunction = types.new_class("DynamicFunction")
    # class_body(DynamicFunction.__dict__)
    # func = DynamicFunction()
    # print(func(6))  # 12
    # ```
    #
    # Это крайне экзотический способ, почти бесполезный в
    # практике, но демонстрирует гибкость Python.

#endfunction

#------------------------------------------
#
#------------------------------------------
#beginmodule
if __name__ == "__main__":
    _01_ ()
#endif

#endmodule
