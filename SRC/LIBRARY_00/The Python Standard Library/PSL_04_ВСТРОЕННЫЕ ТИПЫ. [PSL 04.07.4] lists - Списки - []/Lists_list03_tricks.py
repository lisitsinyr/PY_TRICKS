#------------------------------------------
# Lists_list03_tricks ():
#------------------------------------------
def Lists_list03_tricks ():
    """Lists_list03_tricks"""
#beginfunction
    print (f'#-----------------------------')
    print (f'# {Lists_list03_tricks.__name__}')
    print (f'#-----------------------------')

    # 1. Merging two lists into a dictionary
    x = ['name', 'age', 'country']
    y = ['Yoko', 60, 'Angola']
    dict1 = dict (zip (x, y))
    print (dict1)
    # Output: {'name': 'Yoko', 'age': 60, 'country': 'Angola'}

    # 2. Finding Permutations of a string
    from itertools import permutations
    def get_permutations (s: str):
        arr = []
        for i in permutations (s):
            arr.append (''.join (i))
        return arr
    print (get_permutations ('ABC'))
    # Output: ['ABC', 'ACB', 'BAC', ‘BCA’, 'CAB', 'CBA']

    # 3. Unpacking a list using the star operator
    names = ['John', 'Mary', 'Lisa', 'Rose']
    boy, *girls = names
    print (boy)
    print (girls)
    # Output: John ['Mary', 'Lisa', 'Rose']

    # Используем * для мерджа списка, кортежа и множества в одну строчку
    # Для того, чтобы это сделать самый элегантный способ - использование *
    # Звездочки можно использовать в качестве префиксов для распаковки их элементов.
    # Но помимо распаковки, звездочки также можно использовать для деструктуризации присваиваний в Python.
    A = [1, 2, 3]
    B = (4, 5, 6)
    C = {7, 8, 9}
    L = [*A, *B, *C]
    print (L)
    # [1, 2, 3, 4, 5, 6, 8, 9, 7]

    # В Python удаление и возврат элемента из списка можно сделать несколькими способами.
    # 1. Удаление элемента из списка:
    # Чтобы удалить элемент из списка, вы можете использовать метод remove() или del.
    my_list = [1, 2, 3, 4, 5]
    my_list.remove (3)
    print (my_list)
    del my_list [2]
    print (my_list)
    # 2. Возврат и удаление элемента из списка:
    # Если вам нужно удалить элемент и вернуть его для дальнейшего использования, вы можете использовать метод pop(). Вот пример:
    # Исходный список
    my_list = [10, 20, 30, 40, 50]
    # Возврат и удаление последнего элемента
    last_element = my_list.pop ()
    print (last_element)  # 50
    print (my_list)  # [10, 20, 30, 40]
    # Возврат и удаление элемента по индексу
    first_element = my_list.pop (0)
    print (first_element)  # 10
    print (my_list)  # [20, 30, 40]
    # Таким образом, вы можете использовать методы remove(), del и pop() для удаления и возврата элементов из списка в Python.

    # Методы списка .sort() и .reverse()
    #
    # У списка (и только у него) есть особые методы .sort() и
    # .reverse() которые делают тоже самое, что соответствующие
    # функции sorted() и reversed(), но при этом:
    #
    # Меняют сам исходный список, а не генерируют новый.
    #
    # Возвращают None, а не новый список.
    #
    # Поддерживают те же дополнительные аргументы;

    # В Python существует несколько методов для удаления элементов из списка, но все они различаются по способу применения и целям:
    # list.remove(value) — удаляет первый элемент с указанным значением value из списка
    # list.pop(index) — удаляет и возвращает элемент по заданному индексу (если индекс не указан, удаляется последний элемент)
    # del list[index] — удаляет элемент по индексу без возврата значения и может удалять срезы списка
    # Методы remove, pop и del добавляют гибкости в удалении элементов списка, позволяя удалять по значению, по индексу или по срезу.
    # YoaneHve no 3Ha4eHuW C NMoOmOllbwW remove()
    fruits = ['apple', 'banana', 'cherry', 'banana']
    fruits.remove ('banana')
    print (fruits)  # Bowenet: ['apple', ‘cherry', ‘banana']
    # Yaanenve no uHgeKcy C nomollbi0 pop( )
    numbers = [10, 20, 30, 40]
    removed_number = numbers.pop (1)  # Yaannet 3anemeHT c wH@ekcom 1 uv BO3BpaljaeT ero
    print (numbers)  # BeBeget: [10, 30, 40]
    print (removed_number)  # Buipeget: 20
    # YoaneHne no wHgekcy unu cpe3y c nomoubwo del
    letters = ['a', 'b', 'c', 'd', 'e']
    del letters [2]  # Yaganset anement c uHgekcom 2
    print (letters)  # Boiweget: ['a', 'b', ‘d', ‘e']
    del letters [1:3]  # Yganaet cpe3 (3nemeHTbl c uHgeKcamu 1 u 2)
    print (letters)  # Boiweget: ['a', ‘e']

    # Объединение списка строк в одну строку
    list_of_strings = ['My', 'name', ' is ', 'Alex']
    # Vcnonb30BaHue jOin c pa3genutenem ' '
    # Mertog join() nosBonseT o6beQuHUTb CNMCOK CTPOK B OAHy CTpoKy.
    print (' '.join (list_of_strings))
    # BpiBog: My name is Alex

    # Одновременный доступ к индексу и значению
    arr = [2, 4, 6, 3, 8, 10]
    for index, value in enumerate (arr):
        print (f"At Index {index} The Value Is -> {value}")
    '''Output
    At Index © The Value Is -> 2
    At Index 1 The Value Is -> 4
    At Index 2 The Value Is -> 6
    At Index 3 The Value Is -> 3
    At Index 4 The Value Is -> 8
    At Index 5 The Value Is -> 10
    '''

    # Поиск уникальных и повторяющихся элементов в списке в Python
    myList = [9, 1, 5, 9, 4, 2, 7, 2, 9, 5, 3]
    mySet = set (myList)
    print (mySet)

    # Получение доступа к индексу в цикле for
    my_list = ["apple", "banana", "cherry"]
    for index, item in enumerate (my_list):
        print (index, item)

    # Превращение списка в одну строку
    myc_list = ["Python", "is"  "good", "Programming", "Language"]
    string = ""
    for x in my_list:
        string = string + x + " "
    print (string)
    # Новый способ с использованием join()
    print (" ".join (my_list))

    # Разница между списками
    def difference_by (a, b, fn):
        b = set (map (fn, b))
        return [item for item in a if fn (item) not in b]
    from math import floor
    difference_by ([2.1, 1.2], [2.3, 3.4], floor)  # [1.2]
    difference_by ([{'x': 2}, {'x': 1}], [{'x': 1}], lambda v: v ['x'])  # [ {

    # Распаковка массива (iterable unpacking) — это удобный
    # синтаксис для присваивания элементов iterable объектов
    # (списков, кортежей и т. д.) отдельным переменным.
    # Основные моменты, которые нужно знать:
    # — Распаковка производится с помощью звездочки *.
    # — Количество переменных должно соответствовать количеству
    # элементов в iterable объекте, иначе возникнет ошибка.
    # — Можно использовать распаковку для пропуска элементов.
    # — Для сбора оставшихся элементов в список используется
    # конструкция *others.
    # — Распаковка работает с вложенными списками.
    # — Формат распаковки можно использовать и при передаче
    # аргументов в функции.
    numbers = [1, 2, 3]
    # PacnakoBka B NepeMeHHbIe
    first, second, third = numbers
    print (first)  #1
    print (second)  # 2
    print (third)  # 3
    # IIponyck 3NeMeHTOB
    first, _, third = numbers
    print (first)  #1
    print (third)  # 3
    # COop octaTkKa B cnucoK
    first, *other = numbers
    print (first)  # 1
    print (other)  # /2, 3]
    # PacnakOBKa B/IOKeHHbIX CMCKOB
    one, two, (three, four) = [1, 2, [3, 4]]
    print (three)  # 3
    print (four)  # 4
    # Ilepegaya pacnakosku B @yHKyUIO
    print (numbers)  # /1, 2, 3]
    print (*numbers)  # 7 2 3
    def sum (a, b, c):
        print (a + b + c)
    sum (*numbers)  # 6

    # Создание вложенных списков
    # Вложенный список - это список, содержащий другие списки в качестве его элементов. Создание вложенного списка в Python - это простой процесс. Вы просто создаете список, как обычно, но вместо того чтобы добавлять одиночные элементы, вы добавляете другие списки. Например, nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].
    # Добавление вложенного списка
    # Добавление нового вложенного списка в существующий список также является прямолинейным процессом. Вы просто используете метод .append() для добавления нового списка. Например, если вы хотите добавить новый список [10, 11, 12] в наш вложенный список, вы бы написали nested_list.append([10, 11, 12]).
    # Доступ к элементам вложенных списков
    # Доступ к элементам вложенного списка осуществляется также, как и к элементам обычного списка, только с дополнительным индексированием для вложенных списков. Например, если вы хотите получить доступ к числу 5 в приведенном выше вложенном списке, вы бы использовали nested_list[1][1].
    # Изменение элементов вложенных списков
    # Изменение элементов во вложенных списках также является прямолинейным процессом. Точно также, как вы бы изменили элемент в обычном списке, вы просто обращаетесь к нужному элементу с помощью индекса и присваиваете ему новое значение. Например, nested_list[2][2] = 10 заменит число 9 на число 10 в нашем вложенном списке.
    nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    print (nested_list [0])
    print (nested_list [0] [1])

    # На основе итерируемых объектов можно удобно и без циклов
    # строить списки в одну строчку — такой синтаксис называется
    # списковыми включениями.
    # Сейчас подробнее разберем именно списки, но по такому же
    # принципу можно создавать и словари.
    # В квадратных скобках вы пишите самую обычную конструкцию
    # цикла for, но само выражение ставите перед ключевым словом
    # for. Также можно добавлять условия в конце записи.
    # Как правило, списковые включения работают заметно быстрее,
    # чем циклы. Однако, злоупотреблять этим не рекомендуется, так
    # как это зачастую снижает читаемость кода.
    [number ** 2 for number in range (10)]
    # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
    [number for number in range (10) if number % 2 == 0]
    # [0, 2, 4, 6, 8]
    {number: number ** 2 for number in range (5)}
    # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

    # Три способа выделить уникальные элементы списка
    # Частый запрос среди новичков по версии AnswerThePublic.
    # Дополним привычное представление об удалении дубликатов
    # парой трюков.
    # Допустим, у нас есть список:
    list_inp = [100, 75, 100, 20, 75, 12, 75, 25]
    # set
    set_res = set (list_inp)
    print ("The unique elements of the input list using set():\n")
    list_res = (list (set_res))
    # not in
    for item in list_inp:
        if item not in list_res:
            list_res.append (item)
    # numpy.unique
    import numpy as np
    res = np.array (list_inp)
    unique_res = np.unique (res)

    # Удаление элементов в списке во время цикла
    a = [1, 2, 3, 4]
    for item in a [:]:
        if even (item):
            a.remove (item)
    # a = [1, 3]

    # Распаковка списков и кортежей в аргументы
    # Распаковка списков и кортежей в аргументы
    # Когда у вас есть список или кортеж, и нужно передать его
    # элементы в функцию, можно сделать это гораздо элегантнее,
    # распаковав данные в одну строку. Вместо того чтобы
    # передавать каждый элемент по отдельности, можно использовать
    # * для распаковки.
    # Пример №1
    def greet (name, age):
        print (f"Привет, {name}! Тебе уже {age} лет.")

    data = ["Алекс", 25]
    greet (*data)
    # Результат: Привет, Алекс! Тебе уже 25 лет.
    # *data — распаковывает список или кортеж, передавая каждый
    # элемент в соответствующий аргумент функции.
    # Для словарей можно использовать ** для распаковки ключей и
    # значений: **data. В данном случае **data распакует словарь и
    # передаст его ключи как имена аргументов.
    # Распаковка — это удобный и элегантный способ передавать
    # данные в функции, особенно когда у вас есть коллекции или
    # словари. Простой способ упростить код и повысить его
    # читаемость.

    # Распаковка значений в Python - это способ присвоения
    # значений из итерируемых объектов переменным. Это позволяет
    # извлечь значения из списка, кортежа, строки или других
    # итерируемых объектов и присвоить их отдельным переменным.
    # Комбинации с примерами и краткими описаниями:
    # 1. Распаковка в несколько переменных:
    a, b, c = 1, 2, 3
    # a = 1, b = 2, c = 3
    # Присваивание значений из кортежа переменным.
    # 2. Распаковка посимвольно в строки:
    a, b = "12"
    # a = '1', b = '2'
    # Разделение строки на отдельные символы и присваивание их
    # переменным.
    # 3. Распаковка с использованием звёздочки (*):
    a, *b = 1, 2, 3
    # a = 1, b = [2, 3]
    # Сбор оставшихся значений в список с использованием
    # звёздочки.
    # 4. Распаковка в переменную со звёздочкой (*):
    a, *b, c = 1, 2, 3, 4
    # a = 1, b = [2, 3], c = 4
    # Присваивание первого и последнего значения, а остаток
    # помещается в список.
    # 5. Игнорирование значений при распаковке:
    a, _, b = 7, 8, 9
    # a = 7, b = 9 (значение 8 игнорируется)
    # Пропуск значений, которые не нужны при присвоении.
    # Различные итерируемые объекты:
    # Можно использовать любые итерируемые объекты, такие как
    # списки, кортежи, строки, объекты, поддерживающие итерацию и
    # даже функция range():
    # - Список:
    a, b, c = [4, 5, 6]
    # a = 4, b = 5, c = 6
    # - Кортеж:
    x, y = (10, 20)
    # x = 10, y = 20
    # - Строка:
    char1, char2, char3 = "xyz"
    # char1 = 'x', char2 = 'y', char3 = 'z'
    # - Использование range():
    a, b, c = range (1, 4)
    # a = 1, b = 2, c = 3
    # Распаковка значений в Python - удобный и эффективный способ
    # присваивания значений переменным из итерируемых объектов,
    # делая код более читаемым и компактным. Это дает гибкость при
    # работе с данными различных типов и структур.

    # Разница между list.sort() и sorted() в Python
    # Differences and similarities
    # The primary difference between the two is that list.sort() will sort the list in-place, mutating its indexes and returning None, whereas sorted() will return a new sorted list leaving the original list unchanged. Another difference is that sorted() accepts any iterable while list.sort() is a method of the list class and can only be used with lists.
    nums = [2, 3, 1, 5, 6, 4, 0]
    print (sorted (nums))  # [0, 1, 2, 3, 4, 5, 6]
    print (nums)  # [2, 3, 1, 5, 6, 4, 0]
    print (nums.sort ())  # None
    print (nums)  # [0, 1, 2, 3, 4, 5, 6]
    # Both list.sort() and sorted() have the same key and reverse optional arguments and can be called on each list element prior to making comparisons.
    # When to use each one
    # list.sort() should be used whenever mutating the list is intended and retrieving the original order of the elements is not desired. On the other hand, sorted() should be used when the object to be sorted is an iterable (e.g. list, tuple, dictionary, string) and the desired outcome is a sorted list containing all elements.

    # list.sort() сортирует список на месте, изменяя его, и
    # возвращает None, тогда как sorted() создает новый
    # отсортированный список, оставляя оригинал неизменным.
    # Оба метода имеют параметры key и reverse, позволяя
    # кастомизировать сортировку.
    # list.sort() используется для изменения оригинального
    # списка.
    # sorted() возвращает новый отсортированный список
    # из любого итерируемого объекта.

    # Почему list += list быстрее, чем list = list + list?
    # В Python оператор += для списков и выражение list = list +
    # list дают одинаковый результат, но работают по-разному.
    # Разница в том, что += изменяет список на месте, а + создаёт
    # новый объект.
    # Рассмотрим пример:
    lst = [1, 2, 3]
    lst += [4, 5, 6]  # список изменяется на месте
    # Этот вариант использует list.__iadd__(), который
    # модифицирует текущий объект, не создавая новый список.
    # Теперь посмотрим на этот пример:
    lst = [1, 2, 3]
    lst = lst + [4, 5, 6]  # создаётся новый список
    # Здесь вызывается list.__add__(), который создаёт новый
    # список, копируя оба исходных, что занимает больше времени и
    # памяти.
    # Ключевая разница:
    # += (инплейсная операция) → изменяет исходный список, без
    # копирования
    # + создаёт новый список, копируя данные из обоих
    # += работает быстрее, что особенно заметно на больших
    # структурах, так как он не копирует данные, а напрямую
    # изменяет список.
    # Используйте +=, если оригинальный объект можно
    # модифицировать, и +, если важна его неизменяемость.

    # Почему dict в Python быстрее list? (Хеш-таблицы vs.Линейный поиск)
    # Пример:
    data = ["Alice", "Bob", "Charlie"]
    # Линейный поиск за O(n)
    print ("Bob" in data)  # True
    # Поиск в словаре за O(1)
    data_dict = {"Alice": 1, "Bob": 2, "Charlie": 3}
    print ("Bob" in data_dict)  # True
    # list – это упорядоченный массив элементов. Поиск
    # выполняется линейно (O(n)), так как Python проверяет каждый
    # элемент по очереди.
    # dict – это хеш-таблица, где ключи хешируются и хранятся в
    # специальных слотах. Поиск выполняется за O(1) в среднем
    # случае, так как Python напрямую обращается к нужному слоту,
    # используя хеш-функцию.
    # Вывод: если нужна быстрая проверка наличия элемента –
    # используй dict или set.

    # Основные примеры использования списковых включений
    # Списковые включения — это мощный и лаконичный инструмент для
    # работы с коллекциями в Python. Рассмотрим 4 основных случая
    # использования этого подхода:
    # 1. Основы списковых включений — позволяют создавать новые
    # списки на основе существующих итерируемых объектов, сокращая
    # и упрощая код:
    numbers = [x for x in range (5)]
    # Вывод: [0, 1, 2, 3, 4]
    # 2. Списковые включения с условием — можно фильтровать
    # элементы, добавляя условие, которое определяет, какие
    # элементы попадут в новый список:
    # even_numbers = [x for x in range(10) if x % 2 == 0]
    # Вывод: [0, 2, 4, 6, 8]
    # 3. Вложенные списковые включения — этот метод полезен для
    # создания многомерных структур данных, таких как матрицы, или
    # для работы с вложенными циклами:
    matrix = [[x for x in range (3)] for _ in range (3)]
    # Вывод: [[0, 1, 2], [0, 1, 2], [0, 1, 2]]
    # 4. Создание множеств и словарей — cписковые включения можно
    # адаптировать для создания других коллекций, таких как
    # множества и словари.
    squared_dict = {x: x * x for x in range (5)}
    # Вывод: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

    # Фильтрация и преобразование списков в Python
    # В Python удобно работать со списками с помощью list
    # comprehension и функций высшего порядка (filter, map).
    # Пример:
    names = ["Анна", "Иван", "Петр", "Ольга", "Алексей"]
    # Фильтруем имена, которые начинаются на "А" и преобразуем в верхний регистр
    filtered_names = [name.upper () for name in names if
                      name.startswith ("А")]
    print (filtered_names)  # Вывод: ['АННА', 'АЛЕКСЕЙ']
    # Разбор:
    # List comprehension — краткий и эффективный способ
    # обработки списков.
    # if name.startswith("А") — фильтруем элементы по условию.
    # .upper() — преобразуем строки в верхний регистр.
    # Запомни:
    # List comprehension — мощный инструмент для работы со
    # списками.
    # Можно использовать map() и filter() как альтернативу.

    # Сортировка списков
    # В Python есть два способа сортировки списка: встроенный
    # метод списка list.sort() и встроенная функция sorted(). Вот
    # в чем заключается их отличие:
    # - Функция sorted() принимает итерируемый объект и возвращает
    # новый отсортированный список, не изменяя исходный.
    # - Метод list.sort() сортирует список на месте, то есть
    # изменяет исходный список.
    numbers = [6, 9, 3, 1]
    sorted_numbers = sorted (numbers)
    print (sorted_numbers)
    # [1, 3, 6, 9]
    numbers = [6, 9, 3, 1]
    numbers.sort ()
    print (numbers)
    #[1, 3, 6, 9]

    # Почему нельзя изменять список во время итерации?
    # В Python изменение списка (list) во время итерации может
    # привести к неожиданным результатам. Давай разберёмся, как
    # правильно удалять элементы!
    # Ошибка при удалении во время итерации:
    numbers = [1, 2, 3, 4, 5]
    for num in numbers:
        if num % 2 == 0:
            numbers.remove (num)  #  Ошибка! Пропустит некоторые элементы
    print (numbers)  # Вывод: [1, 3, 5] (но не всегда предсказуемо)
    # Разбор:
    # for перебирает список по индексам, но remove() сдвигает
    # элементы, нарушая порядок.
    # В результате итератор пропускает некоторые элементы.
    # Как правильно удалять элементы?
    # 1 Используем копию списка:
    numbers = [1, 2, 3, 4, 5]
    for num in numbers [:]:  #  Создаём копию списка
        if num % 2 == 0:
            numbers.remove (num)
    print (numbers)  # Вывод: [1, 3, 5]
    # 2 Используем list comprehension:
    numbers = [1, 2, 3, 4, 5]
    numbers = [num for num in numbers if num % 2 != 0]  # Фильтрация
    print (numbers)  # Вывод: [1, 3, 5]
    # 3 Используем filter():
    numbers = [1, 2, 3, 4, 5]
    numbers = list (filter (lambda x: x % 2 != 0, numbers))  # Фильтрация через filter()
    print (numbers)  # Вывод: [1, 3, 5]
    # Запомни:
    # Никогда не изменяй список во время итерации.
    # Используй [:], list comprehension или filter().
    # Ошибка связана со смещением индексов при remove().

    # Преобразование изменяемых данных в неизменяемые
    # Изменяемые данные (например, словари или списки)  —  это
    # структуры, к которым могут быть добавлены новые значения.
    # Неизменяемые данные, в противоположность изменяемым, после
    # создания остаются неизменными. Посмотрите, как можно
    # преобразовать изменяемый тип данных в неизменяемый.
    Ist = [1, 2, 3]  # WU3mMeHsembin cnucoKk
    newlist = frozenset (lst)
    newlist.append (4)  # Owv6Kka, Tenepb 3To U3MeHUTb HeNb3A

    # frozensets используются для создания неизменяемых множеств.
    # Основные особенности frozensets:
    # — Они неизменяемы, то есть элементы нельзя добавить или
    # удалить после создания.
    # — Они могут использоваться как ключи в словарях, так как
    # неизменяемы.
    # — Они быстрее обычных множеств в операциях, так как являются
    # неизменяемыми.
    # Здесь мы создали frozenset с элементами. Попытка добавить
    # элемент вызывает ошибку, так как frozensets неизменяемы.
    # Затем frozenset используется как ключ в словаре.
    fruits = frozenset (["apple", "banana", "orange"])
    print (fruits)
    # frozenset({'apple', 'banana', ‘orange'})
    fruits.add ("grape")
    # AttributeError: '‘frozenset' object has no attribute ‘add'
    d = {fruits: "Set of fruits"}
    print (d)
    # {frozenset({'apple', ‘bananajge"brange'}): 'Seft-of fruits'}

    # List Comprehension
    # List Comprehension — это удобный и компактный способ
    # создания списков в Python. Он позволяет создавать новый
    # список, применяя выражение к каждому элементу другого списка
    # (или итерируемого объекта), часто с условием.
    # Зачем это нужно
    # Короче и читабельнее - Заменяет многострочные циклы одной
    # строкой.
    # Быстрее - Обычно работает быстрее, чем обычный цикл for.
    # Синтаксис
    # [выражение for элемент in итерируемый_объект if условие]
    # Выражение - Что добавить в новый список.
    # Элемент - Переменная, которая берет значения из
    # итерируемого объекта.
    # Условие - Фильтр (необязательный).
    # Пример
    numbers = [1, 2, 3, 4, 5]
    squares = [x ** 2 for x in numbers]
    print (squares)  # [1, 4, 9, 16, 25]
    # Почему это надо использовать
    # Экономия времени -  Пишете меньше кода.
    # Читаемость -  Легче понять, что происходит.
    # Гибкость - Можно использовать с любыми итерируемыми
    # объектами (списки, строки, диапазоны и т.д.).

    # Как это работает? — Python: List Comprehension
    # List comprehension — это мощный способ создавать списки в
    # Python одной строкой. Давайте разберём, как работает этот
    # синтаксис.
    # Как это работает:
    # • range(10) генерирует числа от 0 до 9.
    # • Для каждого числа x из range(10) выполняется выражение
    # x**2, которое возводит x в квадрат.
    # • Результаты собираются в список squares.
    # Развернутый аналог:
    squares = []
    for x in range (10):
        squares.append (x ** 2)
    print (squares)  #[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

    # Как оставить в списке только уникальные значения без повторов?
    # Список с повторами:
    num = [4, 8, 5, 8]
    # Можно использовать множества для удаления повторов.
    # Из списка сделаем множество, а из множества  - список:
    list (set (num))
    # [8, 4, 5]
    # Мы действительно получили список уникальных элементов, вот
    # только порядок нарушился.
    # Начиная с Python 3.7 для этих целей подойдут словари, у них
    # гарантированно сохраняется порядок вставки, а так же ключи
    # являются уникальными.
    list (dict.fromkeys (num))
    # [4, 8, 5]
    # Создали словарь с ключами из num и значениями None,
    # преобразовали в список

    # Загонка списка в print() без явного цикла
    # Допустим, нам нужно вывести инвентарь игрока:
    inv = ['Железный меч',
           'Исцеляющее зелье',
           'Деревянный щит',
           'Палка']
    # Сделать это можно с помощью f-строки и join():
    print (f"У вас есть: {', '.join (inv)}")
    # У вас есть: Железный меч, Исцеляющее зелье, Деревянный щит, Палка

    #endfunction

#------------------------------------------
#
#------------------------------------------
#beginmodule
if __name__ == "__main__":
    Lists_list03_tricks ()
#endif

#endmodule
