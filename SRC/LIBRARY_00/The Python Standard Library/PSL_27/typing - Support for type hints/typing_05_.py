#------------------------------------------
# _01_ ():
#------------------------------------------
def _01_ ():
    """_01_"""
#beginfunction
    print (f'#-----------------------------')
    print (f'# {_01_.__name__}')
    print (f'#-----------------------------')

Link: https://t.me/zen_of_python/4322

Дата: 2025-07-03 08:07:01+00:00

Title: Zen of Python

**TypedDict | Куда, зачем**

Для тех, кто стремится писать поддерживаемый код, существует
`TypedDict` («Типизированный словарь»). В этом посте
разберём, зачем нужен, как правильно использовать и какие
возможности открывает.

`TypedDict` — это специальный тип данных, что позволяет
создавать словари с явно заданными типами для ключей и
значений. Таким образом, вы можете описать структуру
словаря, как будто это объект с фиксированными полями.

```
from typing import TypedDict

class User(TypedDict):
    name: str
    age: int
    email: str
```

В обычных словарях Python ключи и значения могут быть
абсолютно любыми, и это даёт большую гибкость, но вместе с
тем усложняет контроль и проверку данных. `TypedDict`
позволяет добавить статическую типизацию к словарям, тем
самым снизить вероятность неожиданных ситуаций с вашими
экземплярами.

В примере выше мы создаем класс `User`, который наследуется
от `TypedDict`. Теперь словари типа `User` должны иметь
ключи `name`, `age` и `email` с типами `str`, `int` и `str`
соответственно.

Теперь при создании экземпляра:

```
user: User = {
    "name": "Alice",
    "age": 30,
    "email": "alice@example.com"
}
```

если в словаре отсутствует обязательный ключ или тип
значения не совпадает, современные инструменты статической
типизации (например, `mypy`) выдадут ворнинг.


Опциональные ключи

Бывает, что не всегда все ключи словаря на месте. В
`TypedDict` их можно сделать необязательными
(`total=False`):

```
class User(TypedDict, total=False):
    nickname: str
    bio: str
```

#endfunction

#------------------------------------------
#
#------------------------------------------
#beginmodule
if __name__ == "__main__":
    _01_ ()
#endif

#endmodule
