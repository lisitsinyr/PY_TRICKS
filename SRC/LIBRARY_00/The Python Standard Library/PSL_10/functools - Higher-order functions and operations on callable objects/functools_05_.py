#------------------------------------------
# _01_ ():
#------------------------------------------
def _01_ ():
    """_01_"""
#beginfunction
    print (f'#-----------------------------')
    print (f'# {_01_.__name__}')
    print (f'#-----------------------------')

    # https://t.me/pythonercode/1645
    # ✈️Библиотека functools в Python - это настоящая сокровищница
    # для разработчиков, стремящихся оптимизировать свой код и
    # расширить функциональные возможности языка. Хотя многие
    # знакомы с такими популярными инструментами, как @lru_cache и
    # partial, эта библиотека скрывает ряд менее известных, но не
    # менее полезных функций.
    #
    # ➡️reduce(): мощь функционального программирования
    #
    # reduce() - это функция, которая применяет указанную функцию
    # к итерируемому объекту, последовательно сводя его к
    # единственному значению. Это мощный инструмент для обработки
    # последовательностей данных, особенно когда нужно выполнить
    # кумулятивные операции.
    #
    # Пример использования:
    # from functools import reduce
    #
    # numbers = [1, 2, 3, 4, 5]
    # product = reduce(lambda x, y: x * y, numbers)
    # print(product)  # Выведет: 120
    #
    # ➡️singledispatch: элегантное решение для перегрузки функций
    #
    # @singledispatch позволяет создавать функции, которые ведут
    # себя по-разному в зависимости от типа переданного аргумента.
    # Это элегантная альтернатива множественным условным
    # операторам.
    # from functools import singledispatch
    #
    # @singledispatch
    # def process(arg):
    #     print(f"Обработка объекта: {arg}")
    #
    # @process.register(int)
    # def _(arg):
    #     print(f"Обработка целого числа: {arg}")
    #
    # @process.register(list)
    # def _(arg):
    #     print(f"Обработка списка длиной {len(arg)}")
    #
    # process("строка")  # Обработка объекта: строка
    # process(42)        # Обработка целого числа: 42
    # process([1, 2, 3]) # Обработка списка длиной 3
    #
    # ➡️total_ordering: автоматическое создание методов сравнения
    #
    # Декоратор @total_ordering значительно упрощает реализацию
    # классов, поддерживающих операции упорядочивания. Достаточно
    # определить методы eq() и один из методов сравнения (lt, le,
    # gt или ge), а остальные будут автоматически созданы.
    # from functools import total_ordering
    #
    # @total_ordering
    # class Person:
    #     def __init__(self, name, age):
    #         self.name = name
    #         self.age = age
    #
    #     def __eq__(self, other):
    #         return self.age == other.age
    #
    #     def __lt__(self, other):
    #         return self.age < other.age
    #
    # p1 = Person("Алиса", 25)
    # p2 = Person("Боб", 30)
    #
    # print(p1 < p2)  # True
    # print(p1 <= p2) # True
    # print(p1 > p2)  # False
    # print(p1 >= p2) # False
    # 🔎В следующем посте рассмотрим ещё несколько функций

#endfunction

#------------------------------------------
#
#------------------------------------------
#beginmodule
if __name__ == "__main__":
    _01_ ()
#endif

#endmodule
