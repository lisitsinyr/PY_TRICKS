#------------------------------------------
# _01_ ():
#------------------------------------------
def _01_ ():
    """_01_"""
#beginfunction
    print (f'#-----------------------------')
    print (f'# {_01_.__name__}')
    print (f'#-----------------------------')
    # Link: https://t.me/python_job_interview/1136
    #
    # Дата: 2025-06-25 11:02:05+00:00
    #
    # Title: Python вопросы с собеседований
    #
    # 🐍 **Python-совет: используй `functools.lru_cache` для
    # ускорения "дорогих" функций**
    #
    # Если у тебя есть функция, результат которой зависит только
    # от входных данных, — кешируй её! Это может ускорить
    # программы в 10–1000 раз, особенно при рекурсии или
    # повторяющихся запросах.
    #
    # 🔧 Пример:
    #
    # ```
    # from functools import lru_cache
    #
    # @lru_cache(maxsize=128)
    # def fib(n):
    #     if n < 2:
    #         return n
    #     return fib(n - 1) + fib(n - 2)
    #
    # print(fib(100))
    # ```
    #
    # 📌 Что делает `lru_cache`:
    # • сохраняет результаты вызова функции
    # • повторные вызовы с теми же аргументами → мгновенный
    # возврат
    # • `maxsize` ограничивает объём кэша (по принципу LRU — least
    # recently used)
    #
    # 🔥 Без кеша `fib(100)` занимает **минуты**
    # ⚡ С кешем — **менее 1 секунды**
    #
    # 🛠️ Применимо к:
    # • рекурсивным вычислениям
    # • функциям, вызывающим API
    # • любым дорогим операциям с неизменяемыми аргументами
    #
    # 🧠 **Вывод:** `@lru_cache` — это одна строка, которая
    # превращает тяжёлую функцию в реактивную. Идеально для
    # оптимизации без изменения логики.

#endfunction

#------------------------------------------
#
#------------------------------------------
#beginmodule
if __name__ == "__main__":
    _01_ ()
#endif

#endmodule
