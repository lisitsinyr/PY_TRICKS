# -*- coding: UTF-8 -*-
__annotations__ = """
annotations:
************
    Built_in_Functions_01_.py
"""
__doc__ = """
doc:
************
    Самые полезные базовые функции Python
    Разбираем на примерах, какие встроенные функции Python нужны и в простых вычислениях,
    и в сложных операциях. Сохраняйте, чтобы не потерять.
    Встроенные функции Python — простые и эффективные решения для широкого спектра задач:
    от простых арифметических вычислений до самых сложных операций над данными.
    Встроенные функции в Python доступны по умолчанию, без использования дополнительных
    модулей или библиотек. Их можно вызвать в любой момент и в любом месте кода.
    В этой статье подробно рассмотрим ключевые встроенные функции, которые помогают
    в повседневной работе.
"""
"""
VENV:
    D:/PROJECTS_LYR/CHECK_LIST/DESKTOP/Python/VENV/P314/Lib/site-packages
"""
#------------------------------------------
# БИБЛИОТЕКИ python
#------------------------------------------
import sys
# appending a path
sys.path.append('D:/PROJECTS_LYR/CHECK_LIST/DESKTOP/Python/VENV/P314/Lib/site-packages')
from pathlib import Path

#------------------------------------------
# БИБЛИОТЕКИ сторонние
#------------------------------------------

#------------------------------------------
# Built_in_Functions_01_ ():
#------------------------------------------
def Built_in_Functions_01_ ():
    """Built_in_Functions_01_"""
#beginfunction
    print ('#-----------------------------')
    print ('#', Built_in_Functions_01_.__name__)
    print ('#-----------------------------')


    # Работа с числами
    # Числа — фундаментальная часть любого языка программирования, и Python не исключение. С ними придётся часто сталкиваться, поэтому важно знать и понимать, как работают базовые встроенные функции для числовых данных.

    # int(): используют для преобразования данных в целочисленный тип. Функция предназначена для представления целых чисел (например, 1, 7, 42).
    a = "123"
    b = 45.6
    a_int = int(a)
    b_int = int(b)
    print(a_int)  # 123
    print(b_int)  # 45

    # float(): также используют для преобразования данных в числа с плавающей точкой. Применяется для представления чисел с дробной частью (например, 1.5, 7.89, 42.0).
    a = "123.45"
    b = 78
    a_float = float(a)
    b_float = float(b)
    print(a_float)  # 123.45
    print(b_float)  # 78.0

    # abs(): возвращает абсолютное значение числа. То есть преобразует отрицательные числа в положительные и оставляет положительные числа без изменений.
    x = -42.5
    y = 57
    x_abs = abs(x)
    y_abs = abs(y)
    print(x_abs)  # 42.5
    print(y_abs)  # 57

    # min() и max(): функции нужны для поиска минимального и максимального значения из списка или набора чисел соответственно.
    numbers = [4, 56, -2, 7, 12]
    min_val = min(numbers)
    max_val = max(numbers)
    print(min_val)  # -2
    print(max_val)  # 56

    # sum(): применяют для суммирования элементов списка или объекта.
    numbers = [1, 2, 3, 4, 5]
    total = sum(numbers)
    print(total)  # 15

    # Работа со строками
    # Имена, сообщения, логи или любая другая текстовая информация — мы постоянно сталкиваемся со строками. Базовые встроенные функции делают процесс работы со строками проще и эффективнее.

    # len(): возвращает длину строки или другого итерируемого объекта. Это полезно, когда вы хотите знать количество символов в строке или элементов в коллекции.
    text = "Hello, World!"
    length = len(text)
    print(length)  # 13

    # str(): преобразует различные типы данных в строковый формат. Например, вы хотите комбинировать текст со значениями других типов данных.
    number = 12345
    number_str = str(number)
    print("Your number is: " + number_str)  # Your number is: 12345

    # input(): используется для чтения строки из стандартного ввода, обычно из клавиатуры. Это полезно для интерактивных программ, где пользователю необходимо ввести какие-то данные.
    name = input("Enter your name: ")
    print("Hello, " + name + "!")

    # print(): одна из наиболее часто используемых функций в Python. Выводит информацию на экран (текст, числа и другие типы данных), а также комбинирует их.
    age = 25
    print("I am", age, "years old.")  # I am 25 years old.

    # Работа со списками и коллекциями
    # Коллекции данных — основа большинства программ. Списки товаров, наборы уникальных значений или упорядоченные пары — в Python есть множество удобных инструментов для создания, преобразования и манипулирования коллекциями.
    # list(), set(), tuple(): нужны для создания различных типов коллекций. Функция list() создаёт список, set() — множество (набор уникальных элементов), а tuple() — кортеж (неизменяемый список).
    data_tuple = tuple([1, 2, 3, 4])
    data_set = set([1, 1, 2, 3, 3])
    data_list = list((5, 6, 7, 8))
    print(data_tuple)  # (1, 2, 3, 4)
    print(data_set)    # {1, 2, 3}
    print(data_list)   # [5, 6, 7, 8]

    # sorted(): сортирует коллекции. Эта функция может сортировать списки, кортежи и даже множества, возвращая отсортированный список.
    numbers = [3, 1, 4, 2]
    sorted_numbers = sorted(numbers)
    print(sorted_numbers)  # [1, 2, 3, 4]

    # reversed(): возвращает итератор с элементами в обратном порядке. Чтобы получить структуру данных из итератора, часто её комбинируют с list().
    numbers = [1, 2, 3, 4]
    reversed_numbers = list(reversed(numbers))
    print(reversed_numbers)  # [4, 3, 2, 1]

    # enumerate(): нужна для удобного способа получения индексов и соответствующих им значений из списка или другой итерируемой коллекции.
    fruits = ["apple", "banana", "cherry"]
    for index, fruit in enumerate(fruits):
        print(index, fruit)
    # Вывод:
    # 0 apple
    # 1 banana
    # 2 cherry

    # Работа с функциональным программированием
    # Python включает в себя несколько встроенных функций для функционального стиля программирования, делая его доступным даже для начинающих разработчиков.
    # map(): применяет заданную функцию ко всем элементам итерируемого объекта. В результате создаётся новый объект-итератор, который можно преобразовать в список или другую коллекцию.
    numbers = [1, 2, 3, 4]
    def square(x):
        return x * x
    squared_numbers = map(square, numbers)
    print(list(squared_numbers))  # [1, 4, 9, 16]

    # filter(): фильтрует элементы итерируемого объекта на основе заданной функции.
    numbers = [1, 2, 3, 4, 5]
    def is_even(x):
        return x % 2 == 0
    even_numbers = filter(is_even, numbers)
    print(list(even_numbers))  # [2, 4]

    # lambda: позволяет создавать анонимные функции на лету. Это краткая запись функций, которые можно использовать один раз или передать как аргумент другим функциям.
    numbers = [1, 2, 3, 4]
    squared_numbers = map(lambda x: x * x, numbers)
    print(list(squared_numbers))  # [1, 4, 9, 16]

    # Управление выполнением программы
    # При разработке программ часто нужно управлять потоком выполнения: создавать последовательности чисел, определять типы объектов или проверять их принадлежность к определённым классам.
    # range(): генерирует последовательность чисел. Функция может быть особенно полезна при написании циклов.
    for i in range(5):
        print(i)
    # Вывод:
    # 0
    # 1
    # 2
    # 3
    # 4

    # type(): позволяет определить тип объекта, чтобы узнать, с какими данными вы работаете.
    number = 123
    text = "Hello"
    print(type(number))  #
    print(type(text))    #

    # isinstance(): позволяет проверить, принадлежит ли объект к определённому типу или классу (может быть полезно для валидации данных).
    number = 123
    if isinstance(number, int):
        print("It's an integer!")
    # Вывод:
    # It's an integer!

    # Работа с ошибками
    # Даже в хорошо написанном коде могут быть ошибки. Python даёт инструменты, которые помогают разработчикам быстро находить и исправлять неполадки, а также учитывать ситуации, которые могут произойти в программе.
    # try, except: позволяет обрабатывать исключения. Если код в блоке try вызывает ошибку, выполнение переходит к соответствующему блоку except.
    try:
        result = 10 / 0
    except ZeroDivisionError:
        print("You can't divide by zero!")
    # Вывод:
    # You can't divide by zero!

    # raise: позволяет генерировать исключения вручную, что может быть полезно для создания пользовательских условий ошибки.
    value = -1
    if value < 0:
        raise ValueError("Negative values are not allowed!")

    # Вывод
    # ✔ Базовые встроенные функции покрывают множество задач, которые регулярно возникают при программировании на Python.
    # ✔ Хорошее знание базовых встроенных функций ускоряет рабочий процесс и делает код более чистым и эффективным.
    # ✔ Существуют и другие базовые встроенные функции, которые мы не разобрали в статье, но они реже используются на практике.

#endfunction

#------------------------------------------
#
#------------------------------------------
#beginmodule
if __name__ == "__main__":
    print (__annotations__)
    print (__doc__)
    Built_in_Functions_01_ ()
#endif

#endmodule
