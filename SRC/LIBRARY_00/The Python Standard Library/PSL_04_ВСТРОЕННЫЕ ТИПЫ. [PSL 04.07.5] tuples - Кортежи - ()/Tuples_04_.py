#------------------------------------------
# _01_ ():
#------------------------------------------
def _01_ ():
    """_01_"""
#beginfunction
    print (f'#-----------------------------')
    print (f'# {_01_.__name__}')
    print (f'#-----------------------------')

    # Работа с кортежами (tuple) в Python
    
    # Введение в кортежи (tuple) в Python
    # Кортежи (tuple) в Python — это неизменяемые последовательности, 
    # которые могут содержать элементы различных типов. 
    # Они похожи на списки, но в отличие от них, кортежи нельзя изменять после создания. 
    # Это делает кортежи полезными для хранения данных, которые не должны изменяться 
    # в течение выполнения программы. 
    # В отличие от списков, кортежи занимают меньше памяти и работают быстрее, 
    # что делает их идеальными для использования в ситуациях, где важна производительность и неизменяемость данных.

    # Кортежи создаются с помощью круглых скобок () и могут содержать любое количество элементов, включая ноль
    empty_tuple = ()
    single_element_tuple = (1,)
    multiple_elements_tuple = (1, 2, 3)
    mixed_tuple = (1, "hello", 3.14)
    
    # Важно отметить, что для создания кортежа с одним элементом необходимо ставить запятую после элемента, 
    # иначе Python воспримет это как обычное выражение в скобках. Кортежи могут 
    # содержать элементы различных типов, включая числа, строки, списки и даже другие кортежи.

    # Создание кортежей

    # С помощью круглых скобок:
    my_tuple = (1, 2, 3)

    # Без скобок (через запятую):
    my_tuple = 1, 2, 3

    # С помощью функции tuple():
    my_tuple = tuple([1, 2, 3])

    # Создание кортежей с помощью функции tuple() особенно полезно, когда нужно 
    # преобразовать другой итерируемый объект, такой как список или строка, в кортеж. Например:
    list_to_tuple = tuple([4, 5, 6])
    string_to_tuple = tuple("hello")
    print(list_to_tuple)  # Выведет (4, 5, 6)
    print(string_to_tuple)  # Выведет ('h', 'e', 'l', 'l', 'o')

    # Доступ к элементам кортежа осуществляется с помощью индексов, начиная с 0:
    my_tuple = (10, 20, 30)
    print(my_tuple[0])  # Выведет 10
    print(my_tuple[1])  # Выведет 20

    # Индексация позволяет легко получать доступ к отдельным элементам кортежа. Также можно использовать отрицательные индексы для доступа к элементам с конца:
    print(my_tuple[-1])  # Выведет 30
    print(my_tuple[-2])  # Выведет 20

    # Изменение кортежей
    # Кортежи неизменяемы, поэтому изменить элементы кортежа напрямую нельзя. 
    # Однако можно создать новый кортеж, объединяя существующие:
    original_tuple = (1, 2, 3)
    new_tuple = original_tuple + (4, 5)
    print(new_tuple)  # Выведет (1, 2, 3, 4, 5)

    # Также можно использовать срезы для создания нового кортежа на основе части существующего:
    sliced_tuple = original_tuple[1:3]
    print(sliced_tuple)  # Выведет (2, 3)

    # Распаковка кортежей
    # Кортежи можно распаковывать в отдельные переменные:
    my_tuple = (1, 2, 3)
    a, b, c = my_tuple
    print(a)  # Выведет 1
    print(b)  # Выведет 2
    print(c)  # Выведет 3

    # Распаковка особенно полезна, когда функция возвращает несколько значений в виде кортежа. 
    # Также можно использовать символ * для распаковки оставшихся элементов:
    my_tuple = (1, 2, 3, 4, 5)
    a, *b, c = my_tuple
    print(a)  # Выведет 1
    print(b)  # Выведет [2, 3, 4]
    print(c)  # Выведет 5

    # Методы и функции для работы с кортежами

    # count(): Возвращает количество вхождений элемента в кортеж:
    my_tuple = (1, 2, 2, 3)
    print(my_tuple.count(2))  # Выведет 2

    # index(): Возвращает индекс первого вхождения элемента:
    my_tuple = (1, 2, 3)
    print(my_tuple.index(2))  # Выведет 1
    # Эти методы полезны для поиска и подсчета элементов в кортеже.
    # Например, метод count() может быть использован для проверки частоты появления элемента в данных.

    # Встроенные функции

    # len(): Возвращает длину кортежа:
    my_tuple = (1, 2, 3)
    print(len(my_tuple))  # Выведет 3

    # min() и max(): Возвращают минимальный и максимальный элементы кортежа:
    my_tuple = (1, 2, 3)
    print(min(my_tuple))  # Выведет 1
    print(max(my_tuple))  # Выведет 3

    # sum(): Возвращает сумму всех элементов кортежа (если все элементы числовые):
    my_tuple = (1, 2, 3)
    print(sum(my_tuple))  # Выведет 6
    # Эти функции облегчают выполнение различных операций над кортежами,
    # таких как вычисление длины, нахождение минимального и максимального значений,
    # а также суммирование элементов.

    # Примеры использования кортежей в реальных задачах
    # Хранение координат
    # Кортежи часто используются для хранения координат точек в 2D или 3D пространстве:
    point_2d = (10, 20)
    point_3d = (10, 20, 30)

    # Использование кортежей для хранения координат позволяет легко передавать и обрабатывать данные о позициях объектов в пространстве. Например, можно использовать кортежи для хранения координат вершин многоугольника или точек на графике.
    #
    # Возврат нескольких значений из функции
    # Функции могут возвращать несколько значений в виде кортежа:
    def get_min_max(numbers):
        return min(numbers), max(numbers)

    numbers = [1, 2, 3, 4, 5]
    min_val, max_val = get_min_max(numbers)
    print(min_val)  # Выведет 1
    print(max_val)  # Выведет 5

    # Возврат нескольких значений из функции в виде кортежа упрощает код и делает его более читаемым.
    # Это особенно полезно, когда функция должна возвращать несколько связанных значений,
    # таких как минимальное и максимальное значения в списке.
    #
    # Использование в качестве ключей словаря
    # Кортежи могут быть использованы в качестве ключей словаря, так как они неизменяемы:
    my_dict = {(1, 2): "a", (3, 4): "b"}
    print(my_dict[(1, 2)])  # Выведет "a"
    # Использование кортежей в качестве ключей словаря позволяет создавать сложные структуры данных, где ключи представляют собой комбинации значений. Например, можно использовать кортежи для хранения координат точек и значений, связанных с этими точками.

    # Советы и лучшие практики работы с кортежами
    # Используйте кортежи для неизменяемых данных
    # Если данные не должны изменяться, используйте кортежи вместо списков. Это поможет избежать случайных изменений и улучшит производительность. Например, если у вас есть набор константных значений, таких как дни недели или месяцы года, лучше использовать кортежи:
    days_of_week = ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")

    # Распаковка кортежей
    # Используйте распаковку кортежей для удобного присваивания значений переменным:
    coordinates = (10, 20)
    x, y = coordinates
    print(x)  # Выведет 10
    print(y)  # Выведет 20
    # Распаковка кортежей делает код более читаемым и упрощает работу с несколькими значениями. Это особенно полезно при работе с функциями, возвращающими несколько значений.

    # Избегайте вложенных кортежей
    # Вложенные кортежи могут усложнить код и сделать его менее читаемым. Если необходимо хранить сложные структуры данных, рассмотрите использование именованных кортежей (namedtuple) или других структур данных. Например, вместо использования вложенных кортежей для хранения координат и значений, можно использовать именованные кортежи:
    from collections import namedtuple

    Point = namedtuple('Point', ['x', 'y'])
    p = Point(10, 20)
    print(p.x)  # Выведет 10
    print(p.y)  # Выведет 20

    # Используйте именованные кортежи
    # Для улучшения читаемости кода используйте именованные кортежи из модуля collections. Именованные кортежи позволяют обращаться к элементам по именам, что делает код более понятным и удобным для чтения:
    from collections import namedtuple

    Person = namedtuple('Person', ['name', 'age'])
    person = Person(name="Alice", age=30)
    print(person.name)  # Выведет Alice
    print(person.age)  # Выведет 30
    # Именованные кортежи особенно полезны при работе с данными, которые имеют фиксированную структуру, такой как записи в базе данных или результаты API-запросов. Они позволяют сделать код более самодокументируемым и уменьшить вероятность ошибок при доступе к элементам.

#endfunction

#------------------------------------------
#
#------------------------------------------
#beginmodule
if __name__ == "__main__":
    _01_ ()
#endif

#endmodule
