#------------------------------------------
# Sets_set01_01 ():
#------------------------------------------
def Sets_set01_01 ():
    """Sets_set01_01"""
#beginfunction
    print (f'#-----------------------------')
    print (f'# {Sets_set01_01.__name__}')
    print (f'#-----------------------------')

    # Что такое set?
    #
    # Это неупорядоченная коллекция уникальных элементов в Python.
    # Это одна из встроенных структур данных языка, которая
    # используется, когда вам нужно работать с наборами данных,
    # исключая дубликаты и выполняя операции над множествами
    # (например, пересечение, объединение и разность).
    #
    # 🚩Основные характеристики `set`
    #
    # 🟠Неупорядоченность
    # Элементы множества не имеют фиксированного порядка, то есть
    # вы не можете обращаться к элементам по индексу, как в
    # списках или кортежах.
    #
    # 🟠Уникальность элементов
    # Во множестве не может быть дубликатов. Если вы добавите во
    # множество несколько одинаковых элементов, они будут
    # храниться как один экземпляр.
    #
    # 🟠Изменяемость
    # Множества в Python изменяемы: вы можете добавлять, удалять и
    # изменять их элементы. Однако сами элементы множества должны
    # быть неизменяемыми (например, числа, строки, кортежи).
    #
    # 🟠Быстродействие
    # Операции проверки принадлежности (in), добавления и удаления
    # элементов работают очень быстро, благодаря использованию
    # хэш-таблиц в реализации множества.
    #
    # 🚩Создание множества
    #
    # 🟠Пустое множество
    # Для создания пустого множества используется функция set(),
    # так как {} создаёт пустой словарь
    # empty_set = set()
    # print(empty_set)  # Output: set()
    #
    # 🟠Создание множества с элементами
    # Вы можете передать список, строку, кортеж или другой
    # итерируемый объект в функцию set().
    # # Создание множества из списка
    # numbers = set([1, 2, 3, 4, 5])
    # print(numbers)  # Output: {1, 2, 3, 4, 5}
    #
    # # Создание множества из строки (уникальные символы)
    # chars = set("hello")
    # print(chars)  # Output: {'h', 'e', 'l', 'o'}  (порядок может
    # быть разным)
    #
    # 🟠Использование литералов
    # Вы также можете использовать фигурные скобки {} для создания
    # множества
    # fruits = {"apple", "banana", "cherry"}
    # print(fruits)  # Output: {'apple', 'banana', 'cherry'}
    #
    # 🚩Основные операции с множествами
    #
    # 🟠Добавление элементов
    # Используется метод add()
    # my_set = {1, 2, 3}
    # my_set.add(4)
    # print(my_set)  # Output: {1, 2, 3, 4}
    #
    # 🟠Удаление элементов
    # remove() — удаляет элемент, выбрасывая ошибку, если его нет.
    # discard() — удаляет элемент, не выбрасывая ошибку, если его
    # нет.
    # my_set = {1, 2, 3}
    # my_set.remove(2)  # Удаляем элемент 2
    # print(my_set)  # Output: {1, 3}
    #
    # my_set.discard(5)  # Ошибки не будет, если элемента 5 нет
    #
    # pop() — удаляет и возвращает случайный элемент (так как
    # множество неупорядочено)
    # my_set = {1, 2, 3}
    # removed_element = my_set.pop()
    # print(removed_element)  # Например: 1
    # print(my_set)  # Например: {2, 3}
    #
    # 🟠Очистка множества
    # my_set = {1, 2, 3}
    # my_set.clear()
    # print(my_set)  # Output: set()
    #
    # 🟠Проверка наличия элемента
    # Используется оператор in
    # my_set = {1, 2, 3}
    # print(2 in my_set)  # Output: True
    # print(5 in my_set)  # Output: False
    #
    # 🚩Операции над множествами
    #
    # Python поддерживает классические операции теории множеств:
    #
    # 🟠Объединение (`union` или `|`)
    # Возвращает множество, содержащее все элементы из двух
    # множеств.
    # set1 = {1, 2, 3}
    # set2 = {3, 4, 5}
    # print(set1 | set2)  # Output: {1, 2, 3, 4, 5}
    # print(set1.union(set2))  # То же самое
    #
    # 🟠Пересечение (`intersection` или `&`)
    # Возвращает элементы, которые присутствуют в обоих
    # множествах.
    # print(set1 & set2)  # Output: {3}
    # print(set1.intersection(set2))  # То же самое
    #
    # 🟠Разность (`difference` или `-`)
    # Возвращает элементы, которые присутствуют только в одном
    # множестве (а не в другом).
    # print(set1 - set2)  # Output: {1, 2} (только в set1)
    # print(set1.difference(set2))  # То же самое
    #
    # 🟠Симметрическая разность (`symmetric_difference` или `^`)
    # Возвращает элементы, которые есть в одном из множеств, но не
    # в обоих сразу.
    # print(set1 ^ set2)  # Output: {1, 2, 4, 5}
    # print(set1.symmetric_difference(set2))  # То же самое
    #
    # 🚩Неизменяемое множество (`frozenset`)
    #
    # Если вам нужно создать множество, которое нельзя изменить,
    # используйте frozenset
    # frozen = frozenset([1, 2, 3])
    # print(frozen)  # Output: frozenset({1, 2, 3})
    #
    # # frozen.add(4)  # Ошибка: 'frozenset' object has no
    # attribute 'add'


    # Какие объекты можно положить в множество?
    #
    # В Python множество (set) — это неупорядоченная коллекция
    # уникальных элементов, которая работает на основе хеш-
    # таблицы. Это значит, что только хешируемые (immutable)
    # объекты могут быть добавлены в set.
    #
    # 🚩Можно добавить в `set`:
    #
    # Числа (int, float, complex)
    #    s = {1, 2.5, 3+4j}
    #
    # Строки (str)
    #    s = {"apple", "banana", "cherry"}
    #
    # Кортежи (tuple), если они тоже содержат только неизменяемые
    # объекты
    #    s = {(1, 2), ("a", "b")}
    #
    # Булевые значения (bool)** (но True считается 1, а False — 0)
    #    s = {True, False, 1, 0}
    #    print(s)  # {False, True} (0 и 1 не добавятся повторно)
    #
    # 🚩Нельзя добавить в `set`
    #
    # Изменяемые объекты (list, set, dict)
    #    s = { [1, 2, 3] }  #  Ошибка: TypeError: unhashable type:
    # 'list'
    #
    #    s = { {"key": "value"} }  #  Ошибка: TypeError:
    # unhashable type: 'dict'
    #
    # Кортежи с изменяемыми элементами
    #    s = { (1, [2, 3]) }  #  Ошибка: TypeError

#endfunction

#------------------------------------------
#
#------------------------------------------
#beginmodule
if __name__ == "__main__":
    Sets_set01_01 ()
#endif

#endmodule
