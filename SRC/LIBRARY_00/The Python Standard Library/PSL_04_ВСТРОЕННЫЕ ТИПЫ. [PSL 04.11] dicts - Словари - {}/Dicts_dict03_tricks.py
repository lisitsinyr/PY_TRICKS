#------------------------------------------
# Dicts_dict03_tricks ():
#------------------------------------------
def Dicts_dict03_tricks ():
    """Dicts_dict03_tricks"""
#beginfunction
    print (f'#-----------------------------')
    print (f'# {Dicts_dict03_tricks.__name__}')
    print (f'#-----------------------------')

    # Слияние словарей с double asterisk (**)
    # Чтобы лаконично и экономично с точки зрения памяти объединить два словаря, используйте оператор двойной звездочки:
    d1 = {'name': 'Александр', 'age': 25}
    d2 = {'name': 'Александр', 'city': 'Санкт-Петербург'}
    merged_dict = {**d1, **d2}
    # {'name': 'Александр', 'age': 25, 'city': 'Санкт-Петербург''}

    # Что быстрее: словарь или список?
    #
    # Ответ: Поиск будет быстрее в dict и set, потому что это хеш-
    # таблицы, доступ к элементу которых выполняется за O(1). Для
    # list и tuple поиск будет выполняться в среднем за O(n).

    # Извлекаем элементы словаря в Python правильно
    # Обычно для доступа к значению словаря по ключу в Python
    # используют квадратные скобки. Однако можно использовать
    # метод get, который возвращает None, если ключ отсутствует в
    # словаре. Это помогает избежать ошибки KeyError во время
    # выполнения и избавляет от необходимости писать
    # дополнительный код для обработки отсутствующих ключей.

    # Dictionary comprehension. это конструкция, позволяющая компактным способом создавать словари на основе существующих итерируемых объектов
    # Dictionary comprehension применяется в ситуациях, когда
    # нужно:
    # — Быстро создать словарь из списка или другого итерируемого
    # объекта.
    # — Преобразовать одну структуру данных в словарь.
    # — Создать словарь с некоторой обработкой элементов.
    #
    # Основные преимущества dictionary comprehension:
    # — Компактный и читаемый синтаксис по сравнению с циклами.
    # — Лаконичное создание словарей "на лету".
    # — Оптимизированная производительность по сравнению с
    # циклами.

    # Как получить ключ из пары ключ-значение путем перебора элементов словаря
    # Это самый простой способ извлечь ключ по значению. Мы проверяем каждую пару ключ-значение, чтобы найти ключ, связанный с текущим значением.
    #
    # Для этой задачи мы будем использовать метод items(). Этот словарный метод возвращает список кортежей, содержащих пары ключ-значение. В полученном списке мы проверим каждый кортеж, чтобы найти ключ, связанный с нашим значением.
    #
    myDict = {"name": "PythonTurbo", "acronym": "PT"}
    print("Dictionary is:")
    print(myDict)
    dict_items = myDict.items()
    print("Given value is:")
    myValue = "PT"
    print(myValue)
    print("Associated Key is:")
    for key, value in dict_items:
        if value == myValue:
            print(key)
    # Результат:
    #
    # Dictionary is:
    # {'name': 'PythonTurbo', 'acronym': 'PT'}
    # Given value is:
    # PT
    # Associated Key is:
    # acronym
    # Мы создали список элементов в myDict с помощью myDict.items(), а затем проверили каждый элемент в списке, чтобы найти ключ для нашего значения.
    #
    # Как получить ключ по значению с помощью списков
    # Мы можем создать отдельные списки из ключей и значений, а затем найти ключ нужного значения с помощью метода index().
    #
    # Для этой задачи мы сначала создадим список ключей, имеющихся в словаре, используя метод keys(). Затем создадим список значений, используя метод values(). После этого мы получим индекс нужного значения из списка значений с помощью метода index().
    #
    # Мы знаем, что список ключей имеет тот же порядок ключей, что и значения в списке значений. Поэтому индекс значения в списке значений будет таким же, как и индекс связанного с ним ключа в списке ключей. Таким образом, найдя индекс значения в списке значений, мы можем найти ключ в списке ключей по тому же индексу.
    #
    # Это можно сделать следующим образом:
    #
    myDict = {"name": "PythonTurbo", "acronym": "PT"}
    print("Dictionary is:")
    print(myDict)
    dict_keys = list(myDict.keys())
    dict_values = list(myDict.values())
    print("Given value is:")
    myValue = "PT"
    print(myValue)
    val_index = dict_values.index(myValue)
    print("Associated key is:")
    myKey = dict_keys[val_index]
    print(myKey)
    # Выходные данные:
    #
    # Dictionary is:
    # {'name': 'PythonTurbo', 'acronym': 'PT'}
    # Given value is:
    # PT
    # Associated key is:
    # acronym
    # Как получить ключ по значению с помощью list comprehension
    # Для получения ключа, связанного с заданным значением, вместо метода index() можно использовать представление списка. О представлениях списков вы можете почитать в статье “List comprehensions и другие comprehensions в Python”.
    #
    # Чтобы найти ключ, мы создадим список ключей, значения которых равны заданному значению:
    #
    myDict = {"name": "PythonTurbo", "acronym": "PT"}
    print("Dictionary is:")
    print(myDict)
    dict_items = myDict.items()
    print("Given value is:")
    myValue = "PT"
    print(myValue)
    print("Associated key is:")
    myKey = [key for key, value in dict_items if value == myValue]
    print(myKey)
    # Результат:
    #
    # Dictionary is:
    # {'name': 'PythonTurbo', 'acronym': 'PT'}
    # Given value is:
    # PT
    # Associated key is:
    # ['acronym']
    # Заключение
    # В этой статье мы рассмотрели три способа получить из словаря Python ключ по значению: с помощью list comprehension, метода items() и метода index().
    #
    # Перевод статьи Aditya Raj “Get key from value in dictionary“
    # https://www.pythonforbeginners.com/dictionary/get-key-from-value-in-dictionary

    # Для создания словаря из двух списков в Python можно
    # воспользоваться функцией zip(). Функция zip() объединяет
    # элементы двух списков попарно и создает кортежи, которые
    # затем можно преобразовать в словарь.
    # В данном примере мы создаем два списка keys и values, а
    # затем используем функцию zip() для объединения элементов
    # этих списков. Затем мы преобразуем полученные кортежи в
    # словарь с помощью функции dict(). Результат выполнения кода
    # будет следующим:
    # {'a': 1, 'b': 2, 'c': 3}
    # Таким образом, мы создали словарь, в котором ключами
    # являются элементы списка keys, а значениями - элементы
    # списка values.
    keys = ['a', 'b', 'c']
    values = [1, 2, 3]
    my_dict = dict (zip (keys, values))
    print (my_dict)

    # 📱 Фишка: Словари с несколькими значениями для одного ключа с
    # помощью defaultdict
    #
    # Стандартные словари в Python не всегда удобны, если вам
    # нужно хранить несколько значений для одного ключа. Например,
    # если вы хотите, чтобы каждый ключ хранил список значений,
    # вам придется проверять, существует ли уже такой ключ, и если
    # нет — создавать новый список.
    #
    # Однако, в подобных ситуациях, мы можем использовать
    # defaultdict из модуля collections.
    #
    # ️ Пример использования
    #
    from collections import defaultdict

    my_dict = defaultdict(list)
    my_dict["a"].append(1)
    my_dict["a"].append(2)
    my_dict["b"].append(3)

    print(my_dict)
    #
    # В этом примере:
    #
    # — Каждый ключ по умолчанию связан с пустым списком.
    # — Если ключ "a" уже существует, добавляем значение в список.
    # — Если ключа "a" нет, он создается с пустым списком, и
    # добавляется значение.
    #
    # Удобно для работы с группами данных, подсчетами и многими
    # другими задачами.


    # Передаём содержимое словаря
    # Две звездочки перед словарём позволяют передать его
    # содержимое в функцию как аргументы. При этом ключи словаря —
    # имена аргументов.
    # Это полезно при обработке словарей, а также для написания
    # функций-обёрток.
    dictionaryl = {"a": 42, "b": 54}
    dictionany2 = {"x": 420, "y": 54}
    def add (a, b):
        return a + b
    print (add (**dictionaryl))
    # 96
    print (add (**dictionany2))
    # TypeError

    # Какие нюансы есть в использовании чисел как ключей
    #
    # Использование чисел в качестве ключей в словарях Python –
    # это достаточно распространённый случай. Однако у этого
    # подхода есть несколько нюансов, которые нужно учитывать для
    # избежания ошибок.
    #
    # Хешируемость чисел
    #
    # Ключи в словаре должны быть хешируемыми, поскольку словари в
    # Python основаны на хеш-таблицах. Хешируемость означает, что
    # объект имеет неизменное значение хеша в течение его жизни.
    # Числа (как int, так и float) являются хешируемыми, поэтому
    # их можно использовать в качестве ключей.
    # d = {1: "один", 2: "два"}
    # print(d[1])  # "один"
    #
    # Взаимодействие `int` и `float`
    #
    # Python не делает различий между int и float, если их
    # значения равны. Это связано с тем, что у них одинаковое хеш-
    # значение при равенстве.
    # d = {1: "один", 1.0: "float один", 2: "два"}
    # print(d)  # {1: 'float один', 2: 'два'}
    #
    # Пепредсказуемое поведение при работе с `float`
    #
    # Числа с плавающей запятой (float) иногда ведут себя
    # непредсказуемо из-за ошибок округления, которые возникают
    # из-за особенностей представления чисел в памяти компьютера.
    # d = {0.1 + 0.2: "значение"}  # 0.1 + 0.2 не равно точно 0.3
    # из-за округления
    # print(d.get(0.3))  # None, ключ не найден!
    #
    # Производительность
    #
    # Использование чисел как ключей в словарях эффективно с точки
    # зрения производительности. Поскольку числа хешируются быстро
    # и занимают меньше памяти, операции добавления, удаления и
    # поиска выполняются очень быстро.
    #
    # Проблемы при преобразованиях
    #
    # Если ключами словаря являются числа, то при обработке данных
    # (например, чтении из файла или API) можно случайно
    # преобразовать их в строки, что приведёт к созданию новых
    # ключей вместо использования существующих.
    # d = {1: "один", 2: "два"}
    # print(d.get("1"))  # None, строка "1" и число 1 – это разные
    # ключи!
    #
    # Пользовательские объекты с числовыми свойствами
    #
    # Если вы используете пользовательские объекты как ключи и они
    # ведут себя как числа (например, реализуют методы __hash__ и
    # __eq__), то их поведение должно быть совместимо с ожидаемым
    # использованием.
    class MyNumber:
        def __init__(self, value):
            self.value = value

        def __hash__(self):
            return hash(self.value)

        def __eq__(self, other):
            return self.value == other.value

    d = {MyNumber(1): "один"}
    print(d[MyNumber(1)])  # "один"

    # Обмен ключами и значениями словаря
    # Итак, насколько сложно поменять местами значения и ключи в
    # словаре? Совсем несложно, по крайней мере, в Python.
    # Выше представлен действительно изящный способ
    # манипулирования словарями.
    a = {1:11, 2: 22, 3: 33}
    b = dict (zip (a.values (), a.keys ()))
    print (b)

    #endfunction

#------------------------------------------
#
#------------------------------------------
#beginmodule
if __name__ == "__main__":
    Dicts_dict03_tricks ()
#endif

#endmodule
