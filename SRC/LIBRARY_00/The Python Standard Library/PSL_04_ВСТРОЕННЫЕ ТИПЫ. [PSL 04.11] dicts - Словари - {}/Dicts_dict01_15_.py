#------------------------------------------
# _01_ ():
#------------------------------------------
def _01_ ():
    """_01_"""
#beginfunction
    print (f'#-----------------------------')
    print (f'# {_01_.__name__}')
    print (f'#-----------------------------')

    # https://t.me/python_easy_ru/1373
    # 🤔 Почему поиск по ключам в словаре работает быстро?
    #
    # В Python словари (dict) работают очень быстро, потому что
    # они используют хеш-таблицы. Это позволяет находить значения
    # по ключу в константное время O(1) в большинстве случаев.
    # Давайте разберемся, как это работает.
    #
    # 🟠Как устроен словарь в Python?
    # Словарь (dict) — это структура данных, которая хранит пары
    # ключ → значение. Например:
    # data = {"name": "Alice", "age": 25, "city": "New York"}
    # print(data["age"])  # 25
    #
    # 🟠Как работает хеш-таблица?
    # Основной принцип:
    # Хеш-функция (hash()) вычисляет уникальное число (хеш) для
    # ключа.
    # Используется массив (таблица), где данные хранятся по
    # индексам, связанным с хешем.
    # Поиск по ключу — это просто вычисление хеша и обращение к
    # нужному индексу.
    # print(hash("age"))  # Например, вернет 328847234 (будет
    # разным при каждом запуске)
    #
    # Когда мы пишем
    # value = data["age"]
    #
    # 🟠Почему поиск занимает O(1)?
    # Нет линейного поиска: вместо перебора всех элементов Python
    # сразу вычисляет, где находится нужное значение.
    # Операция доступа занимает фиксированное время: hash() +
    # обращение по индексу.
    # Даже при большом количестве элементов скорость остается
    # высокой.
    # Добавим 1 миллион элементов и посмотрим скорость поиска:
    # import time
    #
    # data = {i: i * 2 for i in range(1_000_000)}
    #
    # start = time.time()
    # print(data[999_999])  # Быстро находит ключ!
    # end = time.time()
    #
    # print("Время поиска:", end - start)  # Около 0.000001 сек
    #
    # 🟠Что если хеши совпадут? (Коллизии)
    # Иногда два разных ключа могут иметь одинаковый хеш (редко,
    # но возможно). Тогда Python использует связанный список
    # (chaining) или перехеширование.
    # print(hash("abc") % 10)  # Например, 5
    # print(hash("xyz") % 10)  # Тоже 5 (редко, но бывает)

#endfunction

#------------------------------------------
#
#------------------------------------------
#beginmodule
if __name__ == "__main__":
    _01_ ()
#endif

#endmodule
